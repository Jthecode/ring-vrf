\newcommand{\name}{rVRF}
\section{Security of Our Ring VRF Construction} 
\label{sec:ringvrfconstrnoPK}
\newcommand{\GG}{\grE}
\newcommand{\FF}{\F}
\newcommand{\hash}{H}
\newcommand{\hashG}{\hash_\grE}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\hkeys}{\mathtt{honest\_keys}}
\newcommand{\malkeys}{\mathtt{malicious\_keys}}
\newcommand{\rcom}{R_{\mathsf{dleq}}}
\newcommand{\rsnark}{\Rring}
\newcommand{\counter}{\mathsf{counter}}
\newcommand{\bdv}{\mathcal{B}}
\newcommand{\abort}{\textsc{Abort}}

Before giving the security proof of our protocol, we give the protocol in Section \ref{sec:pederson_vrf} without the abstraction from $ \PedVRF $ for the sake of the clarity of the security proof.

We instantiate parameter generation by constructing a group $\GG$ of order $ p $ and two generators $ G, K \in  \GG$.  We consider three hash functions: $ \hash, \hash': \{0,1\}^* \rightarrow \FF_p $ and a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and . \name \ works as follows:

\begin{itemize}
	\item $ \rVRF.\KeyGen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG $. In the end, it outputs $ \sk = x $ and $ \pk = X $.
	
	%It also generates  PoK for the discrete logarithm of $ X $ for the relation $ \R_{dl} $, $ \NIZK.\Prove(\rdl, (x, (X, G, \GG))) \rightarrow \pi_{dl} $.
	
	%\begin{equation}
	%	\rdl = \{(x,(X,G,\GG)): X,G \in \GG, x \in \FF_p, x = xG\}
	%\end{equation}
	
	%For this, it does the following: $ a \leftsample \FF_p $, $ c = \hash'(aG, X) $, $ s = a + cx $. 
	
	%	\item $ \rVRF.\eval(\sk, \ring, m) $: It lets $ P = \hashG(m, \ring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \ring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\sk, \ring, m) = H(m, \ring, x\hashG(m,\ring)) $.
	%	
	\item $ \rVRF.\Sign(\sk, \ring, m):$ It lets $ P = \hashG(m) $ and computes the pre-output $ \PreOut= x\In$. The signing algorithm works as follows: 

	\begin{itemize}
		
		\item It first commits to its secret key $
		x$ i.e., $ C = X + \openpk K $ where $ \openpk \leftsample \FF_p $.
		\item It generates a Chaum-Pedersen DLEQ proof $ \pi_{dleq} $ showing the following relation, i.e., $ \NIZK.\Prove(\rcom, ((x, \openpk), (G, K, \GG,C,\PreOut,\In))) \rightarrow \pi_{dleq}$
		
		\begin{equation}
			\rcom= \{((x, \openpk), (G, K, \GG,C,\PreOut,\In)): C = xG + \openpk K, W = xP \} \label{rel:commit}
		\end{equation}		
		
		Here $ \Prove $ algorithm runs a non-interactive Chaum-Pedersen DLEQ proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
		Let $R = r_1 G + r_2 K$, $R_m = r_1 \In$, and
		$c = \hash'(\ring, m, \PreOut,C,R,R_m)$.
		Set $\pi_{dleq} = (c,s,\delta)$ where $s = r_1 - c x$ and $\delta = r_2 - c \openpk$.
		\item %It obtains $ crs $ from $ \gcrs $ for the second proof by sending the message $ (\oramsg{learncrs}, \sid) $ to $ \gcrs $. Then,
		%It constructs a Merkle tree $ \mathsf{MT} $ with the nodes $ X_i $ where  $ X_i \in \pk_i $ and $ \pk_i \in  \ring $. We denote its  root by $ \mathsf{root} $. In the end, 
		It generates the second proof $ \pi_{pk} $ for the following relation with  the witness $ (\ring, x, \openpk) $. 		
		
		\begin{equation}
			%\rsnark = \{((\mathsf{copath}, X, \openpk),(G,K,\GG,\mathsf{root}, C)): C-\openpk K = X, \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} \label{rel:snark}
			\rsnark = \{(X, \openpk),(G,K,\GG,\ring, C)): C-\openpk K = X \in \ring\} \label{rel:snark}
		\end{equation}
		
		%Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
		
		The second proof $ \pi_{pk} $ is generated by running 
		$ \NIZK.\Prove(\rsnark,((X, \openpk),(G,K, \GG,\ring, C))) $ 
	\end{itemize}
	In the end, $ \rVRF.\Sign $ outputs $\sigma,W  $ where $ \sigma = (\pi_{dleq}, \pi_{pk}, C) $.
	
	\item $ \rVRF.\Verify(\ring,\PreOut, m, \sigma) $: Given $  \sigma = (\pi_{dleq}, \pi_{pk},C)  $ and $ \ring, W $,
	% it first runs $ \NIZK.\Verify(\rdl,(X_i,G,\GG), \pi_{dl_i}) $ for each $ \pk_i= (X_i, \pi_{dl_i})  \in \ring $. If each of key in $ \ring $ verifies,
	it runs $ \NIZK.\Verify(\rcom,(G, K, \GG,C,\PreOut,\In), \pi_{dleq} ) $ where $ P = \hashG(m, \ring) $. $ \NIZK.\Verify $ for $ \rcom $ works as follows: $ \pi_{dleq} = (c,s, \delta) $, it lets $R' = s G + \delta K + c C$ and $R'_m = s \hashG(m, \ring) + c W$. It
	returns true if $c = \hash'(\ring,m,\PreOut,C,R',R'_m)$. If  $ \NIZK.\Verify(\rcom,(G, K, \GG,C,\PreOut,\In), \pi_{dleq} ) $ outputs 1, it runs $ \NIZK.\Verify(\rsnark, (G,K, \GG,\ring, C), \pi_{MT}) $. 
	If all verification algorithms verify, it outputs $ 1 $ and the evaluation value $ y =  \hash(m,W)  $. Otherwise, it outputs $( 0, \perp) $.
	
\end{itemize}

\subsection{Security Analysis}

Before we start to analyse our protocol, we should define the algorithm $ \gen_{sign} $  for $ \fgvrf $ and show that $ \fvrf $ with $ \gen_{sign} $ satisfies the anonymity defined in Definition \ref{def:anonymity}. $ \fgvrf $ that \name \ realizes runs  Algorithm \ref{alg:gensign} to generate honest signatures.



%\begin{algorithm}
%	\caption{$\gen_{W}(\ring,\pk,m)$}
%	\label{alg:genW}	 	
%	\begin{algorithmic}[1]
	%		\State$ W \leftsample\GG $
	%		%		\State \textbf{get} $ X \in \pk $
	%		%		\If{$\mathtt{DB}[m, \ring] = \perp  $}		
	%		%		\State{$ a \leftsample \FF_p $}		
	%		%		\State{$\mathtt{DB}[m, \ring] := a$}
	%		%		\EndIf
	%		%		\State$ a \leftarrow \mathtt{DB}[m, \ring] $
	%		%		
	%		%		\State \textbf{return} $ aX $
	%		\State \textbf{return} $ W $
	%	\end{algorithmic}
%	
%\end{algorithm}

\begin{algorithm}
	\caption{$\gen_{sign}(\ring,W,\pk,m)$}
	\label{alg:gensign}	 	
	\begin{algorithmic}[1]
		\State $ c,s,\delta \leftsample \FF_p $
		\State $ \openpk \leftsample \FF_p $
		\State $ C =  \pk + \openpk K$
		%\State $ \pi_{dleq} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, K, \GG,C,W,\In)) $
		\State $ \pi_{dleq}  \leftarrow (c,s,\delta)$
		%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
		%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
		\State $ \pi_{MT} \leftarrow \NIZK.\Prove(\rsnark, ((X, \openpk),(G,K, \GG,\ring, C))) $ 
		\State\Return$ \sigma = (\pi_{dleq},\pi_{MT},C,W) $
	\end{algorithmic}
	
\end{algorithm}


\begin{lemma} $ \fgvrf $ running Algorithm \ref{alg:gensign} satisfies anonymity defined in Definition \ref{def:anonymity}.
\end{lemma}

\begin{proof}
	We run a simulated copy of $ \env $ and simulate $ \fgvrf $ with Algorithm \ref{alg:gensign} against $ \mathcal{D} $. Assume that the advantage of $ \mathcal{D} $ is $ \epsilon $. Now, we reduce the anonymity game to the following game where we change the simulation of $ \fgvrf $ by changing the Algorithm \ref{alg:gensign}. In our change, we let $ \pi_{MT} \leftarrow \NIZK.\mathsf{Simulate}(\rsnark, (G,K, \GG,\ring, C))) $. Since $ \NIZK $ is zero knowledge, there exists an algorithm  $ \NIZK.\mathsf{Simulate} $ which generates a proof which is indistinguishable from the proof generated from $ \NIZK.\Prove $. Therefore, our reduced game is indistinguishable from the anonymity game. Since in this game, no public key is used while generating the signature, the probability that  $ \mathcal{D} $ wins the game is $ \frac{1}{2} $. This means that $ \epsilon $ is negligible.		
\end{proof}

We next show that \name \ realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ x\In$ given input $ \In$, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}

\begin{theorem}
	Assuming that $ \hashG, \hash,\hash' $ are random oracles,  the DDH problem is hard in the group structure $ (\GG, G,K, p) $ and NIZK algorithms are zero-knowledge and knowledge sound, \name \ UC-realizes $\fgvrf$ according to Definition \ref{def:uc}.
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of \name \ and simulates the adversary in $ \fgvrf $. 
	\begin{itemize}
		%\item \textbf{[Simulation of $ \gcrs $:] }When simulating $ \gcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rsnark) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \gcrs $.
		
		\item \textbf{[Simulation of $ \oramsg{keygen} $:]} Upon receiving $(\oramsg{keygen}, \sid, \user_i)$ from $\fgvrf$, $ \simulator $ samples $x \leftsample \FF_p$ and obtains the key $X = xG$. It adds $ xG $ to lists $ \hkeys $ and $ \vklist $ as a key of $ \user_i $. 
		In the end, $ \simulator $ returns $(\oramsg{verificationkey}, \sid, X)$ to $\fgvrf$. %Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		\item \textbf{[Simulation of corruption:]} Upon receiving a message $ (\oramsg{corrupted}, \sid, \user_i) $ from $ \fgvrf $, $ \simulator $ removes the public key $ X $ from $ \hkeys $ which is stored as a key of $ \user_i $ and adds $ X $ to $ \malkeys $.
		
		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash, \hash' $ against the real world adversaries. 	
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:HgnoPK}. It selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG $ as an output of the random oracle $ \hashG $. Thus, $ \simulator $ knows \emph{the discrete logarithm of each random oracle output of $\hashG  $}. 
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{7cm}{%
					\underline{\textbf{Oracle $ \hashG $}} \\
					\textbf{Input:} $ m, \ring $ \\
					\textbf{if} $\mathtt{oracle\_queries\_gg}[m] = \perp  $
					
					\tab{$ h \leftsample \FF_p $}
					
					%					\tab{\textbf{for all} $ X \in \ring $}
					%					
					%					\tab{$ W =  hX $}
					%					
					%					\tabdbl{\textbf{if} $ W \in \anonymouskeylist $: \textsc{Abort}}
					%					
					%					\tabdbl{\textbf{else:} \textbf{add} $ W $ \textbf{to} $ \anonymouskeylist $}
					
					\tab{$ P \leftarrow hG $} 
					
					\tab{$\mathtt{oracle\_queries\_gg}[m] := h$}
					
					\textbf{else}:
					
					\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
					
					\tab{$ P \leftarrow hG$}
					
					\textbf{return $ \In$}
					
			}}	
			\caption{The random oracle $ \hashG $}
			\label{oracle:HgnoPK}
		\end{figure}
		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:H}).
		The value $ W $ can be a pre-output generated by $ \rVRF.\Eval $ or can be an anonymous key of  $ m $ generated by $ \fgvrf $ for an honest party. $ \simulator $ does not need to know about this at this point but $ \hash $ should output $ \evaluationslist[m,W] $ in both cases.	 
		If $ W $ is a pre-output, $ \simulator $ needs to find corresponding malicious public key in the real world. If it is the case, $ W $ should be equal to $ x\hashG(m, \ring)= xhG $  where $ xG $ is a public key. 
		So, $ \simulator $ first obtains the discrete logarithm $ h $ of $ \hashG(m) $ from the $ \hashG $'s database and finds out a public key $ X^* = h^{-1}W $.    
		%If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask the output of the message $ m, \ring $ to $ \fgvrf $. 
		If $ X^*$ is not an honest key generated by $ \simulator $, $ \simulator $ can obtain $ \evaluationslist[m,W] $ by sending a message $ (\oramsg{eval}, \sid,X^*,W,m) $.
		Otherwise, it replies by a randomly selected value from $ \FF_p $.
		If $ W $ is a pre-output, then $ \fgvrf $ matches it with $ m, X^* $ and registers $ X^* $ as a malicious key. If $ W $ is an anonymous key, $ \fgvrf $ does not care $ X^* $ and return an honest evaluation value $ \evaluationslist[m,W] $.
		% Remember that $ \fgvrf $ only replies to the evaluation message of $ \simulator $ if $ W $ is not mapped to another message, ring and public key $ (m', \ring', X')   $. $ W $ cannot be map to $ (m', \ring', X')   \neq  (m, \ring, X*)   $ because it would be aborted during the simulation $ \hashG $ if they were mapped to $ W $.
		During the simulation of $ \hash $, if $ \fgvrf $ aborts, it means that there exists $ W' \neq W $ such that $ \anonymouskeymap[m,W'] = X^* $. This means that $ hX^* = W' \neq W  $, but it is impossible because $ W = hX^* $. Therefore, $ \simulator $ never aborts during the simulation of $ \hash $.
		
		We note that $ \fgvrf $ never generates an anonymous key with an honest verification key. Therefore, if $ X^* = h^{-1}W $ is an honest verification key, $ \simulator $ returns a random value because  $ \evaluationslist[m,W] $ is not defined or will be defined in $ \fgvrf $ in this case except with a negligible probability. If it ever happens, $ \env $ distinguishes the simulation via honest signature verification in the real world. So, this case is covered in our simulation in Figure \ref{oracle:H'}.
		
		
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{9cm}{%
					\underline{\textbf{Oracle $ \hash$}} \\
					\textbf{Input:} $ m,W $ 
					
					\textbf{if} $ \mathtt{oracle\_queries\_h}[m, W] \neq \perp $
					
					\tab{\textbf{return $  \mathtt{oracle\_queries\_h}[m,  W] $}}
					
					%					\textbf{send} $ (\oramsg{request}, \sid, \emptyset,W, m) $ \textbf{to} $ \fgvrf $
					%					
					%					\textbf{receive} $ (\oramsg{requests}, \sid, \emptyset, W, m, \setsym{L}_\sigma, y) $ \textbf{from} $ \fgvrf $
					
					%					\textbf{if} $ y = \perp $
					
					{$ P \leftarrow \hashG(m) $}
					
					{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
					
					{$ X^* := h^{-1}W $ // candidate verification key} 
					
					{{\textbf{if} $ X^* \notin \hkeys$ }} 
					
					\tab{\textbf{send} $ (\oramsg{eval}, \sid, W, X^*, m) $ \textbf{to} $ \fgvrf $}
					
					\tab{\textbf{if} $ \fgvrf $ ignores: \abort}
					
					\tab{\textbf{receive} $ (\oramsg{evaluated}, \sid, W, m, y) $ \textbf{from} $ \fgvrf $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m, W]:=y $}
					
					{\textbf{else:} }
					
					\tab{$ y \leftsample \FF_p $}
					
					\tab{$  \mathtt{oracle\_queries\_h}[m,  W]:=y $}
					%					{\textbf{else:} $ \mathtt{oracle\_queries\_h}[m, \ring, W]  = \perp$}
					%					
					%					%\tab{\textbf{return} \textsc{Abort}}
					%					\tab{$ y \leftsample \bin^\lambda $}
					%					
					%					\tab{$\mathtt{oracle\_queries\_h}[m, \ring, W] := y $}
					
					%	\textbf{else:} $  \mathtt{oracle\_queries\_h}[m,  W]:=y $
					
					\textbf{return $  \mathtt{oracle\_queries\_h}[m,  W] $}
					
			}}	
			\caption{The random oracle $ \hash $}
			\label{oracle:HnoPK}
		\end{figure}
		
		The simulation of the random oracle $ \hash' $ (See Figure \ref{oracle:H'}) checks whether the random oracle query $ (\ring,m,W,C,R,R_m) $ is an $ \rcom $ verification query before answering the oracle call. For this, it checks whether $ \fgvrf $ has a recorded valid signature for the message $ m $ and the ring $ \ring $ with the anonymous key $ W $. If there exists such valid signature where $ C $ is part of it, $ \simulator $ checks whether the first proof of the signature $ (c,s,\delta) $ corresponds to $ R, R_m $ as in $ \rVRF.\Verify $ in order to make sure that it is a $ \rcom $ verification query. If it is the case, it assigns $ c $ as an answer of $ \hash' (\ring,m,W,C,R,R_m) $ so that $ \rcom $ verifies. However, if this input has already been set to another value which is not equal to $ c $, then $ \simulator $ aborts because the output of the real world for this signature and the ideal world will be different.
		
		
		\begin{figure}
			\centering
			
			\noindent\fbox{%
				\parbox{10.5cm}{%
					\underline{\textbf{Oracle $ \hash' $}} \\
					\textbf{Input:} $ (\ring, m,W,C,R,R_m) $ \\					
					
					\textbf{send} $ (\oramsg{request\_signatures},\sid, \ring,W,m) $
					
					\textbf{receive} $ (\oramsg{signatures},\sid, \ring,m, \setsym{L}_\sigma) $
					
					\textbf{if} $ \setsym{L}_\sigma \neq \emptylist $ \textbf{and} $ \exists \sigma \in \setsym{L}_\sigma $ where $ C   \in \sigma $
					
					\tab{\textbf{get} $ \pi_1 = (c,s,\delta) \in \sigma $} 
					
					\tab{$ R := sG + \delta K +cC, R_m = s \hashG(m,\ring) + c W $}  
					
					\tab{$ h := \mathtt{oracle\_queries\_gg}[m,W] $ }
					
					\tab{\textbf{if} $ \mathtt{oracle\_queries\_h\_schnor}[\ring, m,W,C,R,R_m]  = \perp $}
					
					\tabdbl{$ \mathtt{oracle\_queries\_h\_schnor}[\ring, m,W,C,R,R_m]  := c$}
					
					\tab{\textbf{else if} $ \mathtt{oracle\_queries\_h\_schnor}[\ring, m,W,C,R,R_m]  \neq c $ \textbf{or}}
					
					\tab{ $ X^* = h^{-1}W \in \hkeys $: \abort}
					
					
					\textbf{else:}
					
					\tab{$ c \leftsample \FF_p $}
					
					\tab{$ \mathtt{oracle\_queries\_h\_schnor}[\ring, m,W,C,R,R_m]  := c$}
					
					{\textbf{return} $ \mathtt{oracle\_queries\_h\_schnor}[\ring, m,W,C,R,R_m] $}
					
			}}
			\caption{The random oracle $ \hash' $}
			\label{oracle:H'}
		\end{figure}
		
		
		%		\item \textbf{[Simulation of $ \oramsg{sign} $]} 
		%		The simulator has a table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
		%		Upon receiving $(\oramsg{sign}, \sid, \ring, m, y)$  from the functionality $\fgvrf$, $ \simulator $ generates the signature $ \sigma $ as follows:
		%		
		%		For the first proof, it samples $ c, s, \delta \in \FF_p $ and $ C, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s, \delta) $. 
		%		In addition, it sets $ R = sG+ \delta K+ cC $ and $ R_m = s \hashG(m, \ring)+ cW $ and maps the input $ \ring,m, W,C, R, R_m$ to $ c $ in the table of the random oracle $ \hash' $ so that $ \pi_1 $ verifies in the real-world execution.  
		%		It adds $ W $ to the list $ \preoutputlist[m, \ring] $.
		%		
		%		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \gcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rsnark,\tau, crs) $ and obtains $ \pi_2 $.
		%		
		%		In the end, $ \simulator $  responds by sending the message $(\oramsg{signature}, \sid, \ring, m, \sigma = (\pi_1, \pi_2, C, W))$ to the $ \fgvrf $.  It also lets $ \mathtt{oracle\_queries\_h}[m, \ring, W] $ be $ y $, if it is not defined yet. If it is defined with another value $ y' \neq y $, then it aborts.
		%TODO: Talk about this abort case happens with a negl probability. 
		
		\item \textbf{[Simulation of $ \oramsg{verify} $]} Upon receiving  $(\oramsg{verify}, \sid, \ring,W, m, \sigma)$ from the functionality $\fgvrf$, $ \simulator $ runs the two NIZK verification algorithms run for $ \rcom, \rsnark $ with the input $ \ring, m, \sigma, W $ described in $ \rVRF.\Verify $ algorithm of \name. If  all verify, it sets $ b_{\simulator} =1 $. Otherwise it sets $ b_{\simulator} =0  $.
		
		\begin{itemize}
			\item 		If $ b_\simulator = 1 $, it sets $ X = h^{-1} W$ where $ h = \mathtt{oracle\_queries\_gg}[m] $ and sends  $ (\oramsg{verified}, \sid, \ring, W, m, \sigma, b_\simulator, X) $ to $ \fgvrf $ and receives back $ (\oramsg{verified}, \sid, \ring, W, m, \sigma, y, b) $. 
			\begin{itemize}
				\item If $ b \neq b_\simulator $, it means that the signature is not a valid signature in the ideal world, while it is in the real world. So, $ \simulator $ aborts in this case.
				
				If $ \fgvrf $ does not verify a ring signature even if  it is verified in the real world, $ \fgvrf $ is in either \ref{cond:uniqueness}, \ref{cond:forgery} or \ref{cond:differentWforsamepk}.
				If $ \fgvrf $ is in \ref{cond:uniqueness}, it means that $ \counter[m,\ring] > |\ring_m| $. If $ \fgvrf $ is in \ref{cond:forgery}, it means that $ X $ belongs to an honest party but this honest party never signs $ m $ for the ring $ \ring $. So, $ \sigma $ is a forgery.	 If $ \fgvrf $ is in \ref{cond:differentWforsamepk}, it means that there exists $ W' \neq W $ where $ \anonymouskeymap[m,W'] = X $. If $ [m,W'] $ is stored before, it means that $ \simulator $ obtained $ W' = hX $ where $ h = \mathtt{oracle\_queries\_h}[m] $ but it is impossible to happen since $ W = hX $.
				\item If $ b = b_\simulator $, it sets $ \mathtt{oracle\_queries\_h}[m,W] = y $, if it is not defined before.
				% In short, if $ \simulator $ aborts because $ b\neq b_\simulator $ it means either $ W $ of an honest party is not unique and $ \adv $ in the real world generates a forgery signature of $ (m, \ring, \sigma) $ with $ W $ or the adversary in the real world generates anonymous keys for $ (m, \ring) $ more than the number of adversarial keys in $ \ring $.
				%				 
				
				%	\item If $ b = b_\simulator $, set $ \mathtt{oracle\_queries\_h}[m, W] = y $. Here, if $ \sigma $ is a signature of an honest party, $ \simulator $ sets its output with respect to the output selected by $ \fgvrf $. 
				%    Remark that we do not need to set $ \mathtt{oracle\_queries\_h\_schnor} $ because it already verifies in the real world.
			\end{itemize}
			\item If $ b_\simulator = 0 $, it sets $ X = \perp $ and sends  $ (\oramsg{verified}, \sid, \ring, W, m, \sigma, b_\simulator, X) $ to $ \fgvrf $. Then, $ \simulator $ receives back $ (\oramsg{verified}, \sid, \ring, W, m, \sigma, \perp, 0) $. 
			%			\begin{itemize}
				%				\item If $ b \neq b_\simulator $, it means that it was a signature of an honest party and $ \NIZK.\Verify $ for $ \rcom $ does not validate in the real world. So, $ \simulator $ sets $ \mathtt{oracle\_queries\_h}[m, \ring,W] = y $ and $ \mathtt{oracle\_queries\_h\_schnor}[\ring, m, W, C, R', R_m'] = c $ where $ R' = sG + \delta K+ cC  $, $ R_m = s \hashG(m,\ring) + cW$. 
				%				Now, the signature verifies in the real world as well.
				%				\item If $ b = b_\simulator $, $ \simulator $ doesn't need to do anything.
				%			\end{itemize}
			
		\end{itemize}
		
		
		
		
		
		
	\end{itemize}
	
	\begin{theorem}\label{thm:rvrf}
		\name \ over the group structure $ (\GG,p,G,K) $ realizes $ \fgvrf $ in Figure \ref{f:gvrf} in the random oracle model assuming that NIZK is zero-knowledge and knowledge extractable, the decisional Diffie-Hellman (DDH) problem are hard in $ \GG  $. 
	\end{theorem}
	
	\begin{proof}
		
		We first show that the outputs of honest parties in the ideal world are indistinguishable from the output of honest parties in the real protocol. 
		
		\begin{lemma}\label{lem:honestoutput}
			Assuming that DDH problem is hard on the group structure $ (\GG, G,K,p) $, the outputs of honest parties in the real protocol \name\ are indistinguishable from the output of the honest parties in $ \fgvrf $.
		\end{lemma}
		
		\begin{proof}
			Clearly, the outputs of the ring signatures in the ideal world identical to the real world protocol because  the outputs are randomly selected by $ \fgvrf $ as the random oracle $ \hash $ in the real protocol. The only difference is the generation of the ring signature (See Algorithm \ref{alg:gensign}) and the anonymous key. The distribution of $ \pi_{dleq} = (c,s,\delta) $ and $ C $ generated by Algorithm \ref{alg:gensign} and the distribution of $ \pi_{dleq} = (c,s,\delta) $ and $ C $ generated by $ \rVRF.\Sign $ are from uniform distribution so they are indistinguishable. Thanks to the zero-knowledge property of NIZK, $ \pi_{pk} $ generated by Algorithm \ref{alg:gensign} and $ \pi_{pk} $ generated by $ \rVRF.\Sign $ are indistinguishable too.  
			
			Now, we show that the anonymous key $ W $ selected randomly fro $ \GG $ and pre-output$	 W $ generated by $ \rVRF.\Sign $ are indistinguishable. For this,  we need show that selecting $ W $ randomly from $ \GG $ and computing $ W $ as $x \hashG(m, \ring) $ are indistinguishable.
			We  show this under the assumption that the DDH problem  is hard.  In other words, we show that if there exists an adversary $ \adv' $ that distinguishes anonymous keys of honest parties in the ideal world and anonymous key of the honest parties in the real protocol then we construct another adversary $ \bdv $ which breaks the DDH problem. 
			We use the hybrid argument to show this.
			We define hybrid simulations $ H_{i} $ where  the anonymous keys of first $ i $ honest parties are computed as described in $ \rVRF.\Sign $ and the rest are computed by selecting them randomly. Without loss of generality, $ \user_1, \user_2, \ldots, \user_{n_h} $ are the honest parties. Thus, $ H_0 $ is equivalent to the anonymous keys of the ideal protocol  and $ H_{n_h}  $ is equivalent to the anonymous keys of honest parties in the real world.  We construct an adversary $ \bdv $ that breaks the DDH problem given that there exists an adversary $ \adv' $ that distinguishes hybrid games $ H_i $ and $ H_{i + 1} $ for $ 0 \leq i < n_h $. $\bdv $ receives the DDH challenges $ X,Y, Z \in \GG $ from the DDH game and simulates the game against $ \adv' $ as follows: $\bdv $ generates the public key of all  honest parties' key as usual by running $ \rVRF.\KeyGen$ except party $ \user_{i+1} $. It lets $ \user_{i+1} $'s public key be $ X $. $ \bdv $ gives $ \GG, G = Y, K $ as parameters of \name. 
			
			%		\begin{figure}
				%		\centering
				%		
				%		\noindent\fbox{%
					%			\parbox{8cm}{%
						%				\underline{\textbf{Oracle $ \hashG $ in \ref{game:DDH} by the DDH adversary $\simulator $}} \\
						%				\textbf{Input:} $ m, \ring $ \\
						%				\textbf{if} $\mathtt{oracle\_queries\_gg}[m, \ring] = \perp  $
						%				
						%				\tab{$ h \leftsample \FF_p $}
						%				
						%				\tab{\fbox{$ P \leftarrow hY $}}
						%				
						%				\tab{$\mathtt{oracle\_queries\_gg}[m, \ring] := h$}
						%				
						%				\textbf{else}:
						%				
						%				\tab{h $\leftarrow \mathtt{oracle\_queries\_gg}[m, \ring]$}
						%				
						%				\tab{\fbox{$ P \leftarrow hY $}}
						%				
						%				\textbf{return $ \In$}
						%				
						%		}}	
				%		\caption{The simulation of the random oracle $ \hashG $ by $\simulator $. The different steps than Figure \ref{oracle:Hg} are in the box.}
				%		\label{oracle:HgbyB}
				%		\end{figure}
			
			$\bdv $ simulates the ring signatures of first $ i $ parties as in the real protocol and the parties $ \user_{i+2}, \ldots, \user_{n_h} $ as follows: it generates a ring signature and its anonymous key by running Algorithm \ref{alg:gensign} and selecting randomly, respectively. The simulation of $ \user_{i + 1} $ is different. It lets the public key of $ \user_{i + 1} $ be $ X$. Whenever $ \user_{i+1} $ needs to sign an input $ m$ for a ring $ \ring $ where $ \pk_{i+1} \in \ring$, it obtains $ P = \hashG(m) = hY $ from $ \mathtt{oracle\_queries\_gg} $ and lets $ W = hZ $. Remark that if $ (X,Y,Z)$ is a DH triple (i.e., $  \mathsf{DH}(X,Y,Z) \rightarrow 1 $), $ \user_{i+1} $ is simulated as in \name \ because $ W = x\In$ in this case. Otherwise, $ \user_{i+1} $ is simulated as in the ideal world because $ W $ is random. So, if $  \mathsf{DH}(X,Y,Z)  \rightarrow 1$, $\simulator $ simulates $ H_{i+1} $. Otherwise, it simulates $ H_{i} $. In the end of the simulation, if $ \adv $ outputs $ i $, $\simulator $ outputs $ 0 $ meaning $  \mathsf{DH}(X,Y,Z) \rightarrow 0$. Otherwise, it outputs $ i + 1 $. The success probability of $\simulator $ is equal to the success probability of $ \adv' $ which distinguishes $ H_i $ and $ H_{i +1} $. Since DDH problem is hard, $\simulator $ has negligible advantage in the DDH game. So, $ \adv' $ has a negligible advantage too. Hence, from the hybrid argument, we can conclude that $ H_0    $ which corresponds the output of honest parties in  \name\ and $ H_q  $ which corresponds to  the output of honest parties in ideal world are indistinguishable.
			
			This concludes the proof of showing the output of honest parties in the ideal world are indistinguishable from the output of the honest parties in the real protocol.
		\end{proof}	
		
		Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.
		
		\begin{lemma} 
			The view of $ \adv $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view of $ \adv $ in its interaction with real honest parties.
		\end{lemma}
		
		
		\begin{proof}
			The  simulation against the real world adversary $ \adv $ is identical to the real protocol except the output of the honest parties and cases where $ \simulator $ aborts. We have already shown in Lemma \ref{lem:honestoutput} that the output of honest parties are indistinguishable from the real protocol. Next, we show that the abort cases happen with a negligible probability during the simulation. $ \simulator $ aborts during the simulation of random oracles $ \hash $ and $ \hash' $ and during the simulation of verification. We have already explained that the abort case during the simulation of $ \hash $ cannot happen. The abort case happens in the simulation of $ \hash' $ if $ W = hX $ where $ X $ is an honest verification key or if $ \mathtt{oracle\_queries\_h\_schnor}[\ring,m,W,C,R,R_m] $ has already been defined by a value which is different than $ c $. The first case happens in $ \hash' $ if $ \fgvrf $ selects a random $ W \in \GG$ for an anonymous key of $ m $ and $ \pk = X $ and the random oracle $ \hashG $ selects a random $ h \in \FF_p  $ where $ \hashG(m) = hG $. Clearly, this can happen with a negligible probability in $ \secparam $. The 
			second case happens in $ \hash' $ if $ \adv $ queries with the input $ (\ring,m,W,C,R,R_m) $ before $ (\pi_1,\pi_2,C,W) $ generated by $ \gen_{sign} $. Since $ C $ is random, the probability that $ \adv $ guesses even $ C $ before it is generated is negligible.
			Now, we are left with the abort case during the verification.
			For this, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we construct another adversary $ \bdv $ which breaks the CDH problem. 
			
			Consider a CDH game in a prime $ p $-order group  $ \GG $ with the challenges $ G,U, V \in \GG$. The CDH challenges are given to the simulator $ \bdv $. Then $ \bdv $ runs a simulated copy of $ \env $ and starts to simulate $ \fgvrf $ and $ \simulator $ for $ \env $. For this, it first runs the simulated copy of $ \adv $ as $ \simulator $ does. $ \bdv $ provides $ (\GG, p, G , K) $ as a public parameter of the ring VRF protocol to $ \adv $.
			
			Whenever $ \bdv $ needs to generate a ring signature for $ m $ on behalf of an honest party with a public key $ X $, it behaves exactly as $ \fgvrf $ except that it runs   Algorithm \ref{alg:gensignbdv} to generate the signature. 
			%			
			%			\begin{algorithm}
				%				\caption{$\gen_{W}(X, m)$}
				%				\label{alg:genWbdv}	 	
				%				\begin{algorithmic}[1]
					%					\If{$ DB_W[m, X] = \perp $}
					%					\State $ W \leftsample \GG$
					%					\State $ DB_W[m, X] := W $
					%				%	\State \textbf{add} $ W $ to list $ \anonymouskeylist[m,\ring] $
					%					\EndIf
					%					\State \textbf{return} $ DB_W[m, X] $
					%				\end{algorithmic}
				%			\end{algorithm}
			
			
			\begin{algorithm}
				\caption{$\gen_{sign}(\ring,W,X,m)$}
				\label{alg:gensignbdv}	 	
				\begin{algorithmic}[1]
					\State $ c,s,\delta \leftsample \FF_p $
					\State $ \openpk \leftsample \FF_p $
					\State $ C =  X + \openpk K$
					\State $ R' = sG +\delta K + cC$
					\State $ R_m = s\hashG(m, \ring) + c W $
					\State $ \mathtt{oracle\_queries\_h\_schnor}[\ring,m, W, C,R',R'_m] = c$						
					\State $ \pi_{dleq} \leftarrow (c,s,\delta) $
					%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
					%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
					\State $ \pi_{\pk} \leftarrow  \NIZK.\Prove(\rsnark,((X, \openpk),(G,K, \GG,\ring, C))) $
					\State \textbf{return} $ \sigma = (\pi_{dleq},\pi_{MT},C,W) $
				\end{algorithmic}
				
			\end{algorithm}
			
			
			Clearly the ring signature of an honest party outputted by $ \simulator $ (remember $ \fgvrf$ generates it by Algorithm \ref{alg:gensign}) and the ring signature generated by $ \bdv $ are the same except that it sets up the random oracle $ \hash' $ so that $ \pi_1 $ verifies for $ \rcom $. Therefore, the simulation of $ \hash' $ is simulated as a usual random oracle by $ \bdv $.
			
			In order to generate the public keys of honest parties, $ \bdv $ picks a random $ r_x\in \FF_p $ and generates the public key of each honest party as $ r_xV$.
			Remark that $ \bdv$  never needs to know the secret key of honest parties to simulate them since $ \bdv $ selects anonymous keys randomly  and generates the ring signatures  without the secret keys. Therefore, generating the honest public keys in this way is indistinguishable. 			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{9cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ m,W $ 
						
						\textbf{if} $ \mathtt{oracle\_queries\_h}[m,  W] = \perp $
						
						\tab{$ y \leftsample \{0,1\}^{\ell_\rVRF} $}
						
						\tab{$  \mathtt{oracle\_queries\_h}[m,  W]:=y $}
						
						
						\textbf{return $  \mathtt{oracle\_queries\_h}[m, W] $}
						
				}}	
				\caption{The random oracle $ \hash $}
				\label{oracle:HbyB}
			\end{figure}
			
			\begin{figure}
				\centering
				
				\noindent\fbox{%
					\parbox{7cm}{%
						\underline{\textbf{Oracle $ \hashG $}} \\
						\textbf{Input:} $ m$ \\
						\textbf{if} $\mathtt{oracle\_queries\_gg}[m] = \perp  $
						
						\tab{$ h \leftsample \FF_p $}
						
						
						\tab{$ P \leftarrow hU $} 
						
						\tab{$\mathtt{oracle\_queries\_gg}[m] := h$}
						
						\textbf{else}:
						
						\tab{$ h \leftarrow \mathtt{oracle\_queries\_gg}[m] $}
						
						\tab{$ P \leftarrow hU$}
						
						\textbf{return $ \In$}
						
				}}	
				\caption{The random oracle $ \hashG $}
				\label{oracle:HgbyB}
			\end{figure}
			
			Simulation of $ \hashG $ is as described in Figure \ref{oracle:HgbyB} i.e., it returns $ hU $ instead of $ hG $. The simulation of $ \hashG $ is indistinguishable from the simulation of $ \hashG $ in Figure \ref{oracle:HgnoPK}. 
			$ \bdv $ simulates the random oracle $ \hash $ in Figure \ref{oracle:HbyB} a usual random oracle. The only difference from the simulation of $ \hash $ by $ \simulator $ is that $ \bdv $ does not ask for the output of $ \hash(m,W) $ to $ \fgvrf $. This difference is indistinguishable from the simulation of $ \hash $ by $ \simulator $ because $ \simulator $ gets it from $ \fgvrf $ which selects it randomly as $ \bdv  $ does. Remark that since $ \hashG $ is not simulated as in Figure \ref{oracle:HgnoPK}, $ \bdv $ cannot check whether $ W $ is an anonymous key generated by an honest key or not.  However, it does not need this information because $ \hash $ is simulated as a usual random oracle.
			
			During the simulation whenever a valid signature $ \sigma = (\pi_{dleq},\pi_{\pk},C,W) $ of message $ m $ signed by $ \ring $ is outputted and $ W \notin \anonymouskeylist[m, \ring] $, $ \simulator $ increments a counter $ \counter[m,\ring] $ and adds $ W $ to $ \anonymouskeylist[m,\ring] $.
			Then it runs $ \mathsf{Ext}(\rsnark,\pi_{\pk_j},(G,K, \GG,\ring, C) ) \rightarrow X, \openpk$ where $ X\in \ring $ and $ C = X + \openpk K $ and $ \mathsf{Ext}(\rcom,\pi_{dleq},(G,K, \GG,\ring, C,W,\hashG(m))) \rightarrow (\hat{x},\hat{\openpk} )$ such that $ C = \hat{x}G + \hat{\openpk} K $ and $ W = \hat{x} \hashG(m) $. 
			
			If $ X  $ is an honest public key and $ X = \hat{x}G $, $ \bdv $ solves the CDH problem as follows: $ W = \hat{x} h U $ where $ h = \mathtt{oracle\_queries\_gg}[m] $. Since $ X = r V $, $ W = \hat{x}huG =rhuV $. So, $ \bdv $ outputs $ r^{-1}h^{-1}W $ as a CDH solution and simulation ends. Remark that this case happens when $ \simulator $ aborts because of \ref{cond:forgery}.
			
			If $  \counter[m,\ring] = t \geq |\ring_{mal}| $, $ \bdv $ obtains all the signatures $ \{\sigma_i\}_{i =1}^t $ that make $ \bdv $ increment $ \counter[m,\ring] $ and solves the CDH problem as follows: Remark that this case happens when $ \simulator $ aborts because of \ref{cond:uniqueness}.
			
			For all $ \sigma_j = (\pi_{com_j},\pi_{\pk_j},C_j,W_j) \in \{\sigma_i\}_{i =1}^t $, $ \bdv $ runs $ \mathsf{Ext}(\rsnark,\pi_{\pk_j},(G,K, \GG,\ring, C_j) ) \rightarrow X_j, \openpk_j$ and adds $ X_j $ to a list $ \setsym{X}  $ where $ X_j\in \ring $ and $ C_j = X_j + \openpk_j K $. One of the following cases happens:
			
			\begin{itemize}
				\item All $ X_j$ in $ \setsym{X} $ are different: If $ \bdv $ is in this case, it means that there exists one public key $ X_a \in \setsym{X} $ which is honest. Then $ \bdv $ runs $ \mathsf{Ext}(\rcom,\pi_{com_a},(G,K, \GG,\ring, C_a,W_a,\hashG(m))) \rightarrow (\hat{x}_a,\hat{\openpk}_a )$ such that $ C_a = \hat{x}_aG + \hat{\openpk}_a K $ and $ W_a = \hat{x}_a \hashG(m) $.  If $ \bdv $ is in this case, $ \hat{x}_aG\neq X_a $ because otherwise it would solve the CDH as described before. Therefore, $ \openpk_a \neq \hat{\openpk}_a $. Since $ X_a + \openpk_a K = \hat{x}_aG + \hat{\openpk}_a K  $ and $ X_a = r_aV $ where $ r_a $ is generated by $ \bdv $ during the key generation process, $ \bdv $ obtains a representation of $ V = \gamma G + \delta K $ where $ \gamma = \hat{x}_ar^{-1}_a  $ and $ \delta = (\hat{\openpk}_a -\openpk)r_a^{-1} $. Then $ \bdv $ stores $ (\gamma, \delta) $ to a list $ \mathsf{rep} $. If $ \mathsf{rep} $ does not include another element $ (\gamma', \delta')  \neq (\gamma, \delta) $, $ \bdv $ rewinds $ \adv $ to the beginning with a new random coin.  Otherwise, it obtains $ (\gamma', \delta') $ which is another representation of $ V $ i.e., $ V = \gamma' G + \delta' K $. Thus, $ \bdv $ can find discrete logarithm of $ V $ on base $ G $ which is $ v = \gamma + \delta \theta $ where $ \theta = (\gamma - \gamma')(\delta' - \delta)^{-1} $. $ \bdv $ outputs $ vU $ as a CDH solution and the simulation ends.
				
				
				\item There exists at least two $ X_a,X_b \in \setsym{X} $ where $ X_a = X_b $. $ \bdv $ runs $ \mathsf{Ext}(\rcom,\pi_{com_a},(G,K, \GG,\ring, C_a,W_a,\hashG(m))) \rightarrow (\hat{x}_a,\hat{\openpk}_a )$ and $ \mathsf{Ext}(\rcom,\pi_{com_b},(G,K, \GG,\ring, C_b,W_b,\hashG(m))) \rightarrow (\hat{x}_b,\hat{\openpk}_b )$ such that $ C_a = \hat{x}_aG + \hat{\openpk}_a K, C_b = \hat{x}_bG + \hat{\openpk}_b K $ and $ W_a = \hat{x}_a \hashG(m), W_b = \hat{x}_b \hashG(m) $. Since $ W_a \neq W_b $, $ \hat{x}_a \neq \hat{x}_b $.  Therefore, $ \bdv $ can obtain  two different and non trivial representation of $ X_a = X_b $ i.e., $ X_a = X_b = \hat{x}_aG + (\hat{\openpk}_a - \openpk_a) K = \hat{x}_bG + (\hat{\openpk}_b - \openpk_b) K  $. Thus, $ \bdv $ finds the discrete logarithm of $ K = U $ in base $ G $ which is $ u = \frac{\hat{x}_a - \hat{x}_b}{\hat{\openpk}_a -\openpk_a -\hat{\openpk}_b + \openpk_b} $. $ \bdv $ outputs $ uV $ as a CDH solution.
			\end{itemize}
			
			
			
			
			
			
			
			
			
			
			
			
			%	
			%		
			%		
			%			$ \bdv $ solves CDH if $ \bdv $ is in the abort case of simulation of $ \hash$ in Figure \ref{oracle:H} by outputting $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $. $ r^{-1}h^{-1}W $ is the CDH solution because $ vU $ is a solution of $ CDH $ where $ V =  $
			%		
			%		is in this case $ \bdv $ outputs  $ r^{-1}h^{-1}W $  where $ X^* = rV $ and $ h = \mathtt{oracle\_queries\_gg}[m,\ring] $ and simulation ends. Remark that if $ \bdv $ aborts during the simulation of $ \hash $ it means that $ X^* $ belongs to an honest party and $ X^* =  h^{-1}W = rV = rvG$.  Therefore, $ r^{-1}h^{-1}W $ is the CDH solution of $ U,V $.
			%				  
			%		During the simulation if $ \bdv $ sees a valid forgery ring signature  $ m, \ring, \sigma = (\pi_{dleq}, \pi_{MT}, C, W) $ where $ W $ is an anonymous key generated by $ \bdv $ for $ (m',\ring') \neq (m, \ring) $, $ \bdv $ aborts. $ \Pr[x\hashG(m',\ring') = W; xG \in \ring'| \ring',W] $ is negligible because $ \hashG $ is a random oracle.
			%		%TODO exact probability
			%				  
			
			%		During the simulation if $ \bdv $ sees a forgery ring signature  $ m, \ring, \sigma = (\pi_{dleq}, \pi_{MT}, C, W) $ where $ X = h^{-1}W $ is an honest key, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{MT} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{dleq} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = xG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$.  Then, $ \bdv $ outputs the CDH of $ U, V $ which is $r^{-1}xU  $. This is correct CDH solution because $ X= rV = xG $, $ V= r^{-1}xG $.
			%		We remark  a forgery signature corresponds to the abort case of $ \simulator $ during the verification because $ \fgvrf $ is in \ref{cond:forgerymalicious}, $ \pk_\simulator  $ is an honest party's key. 
			
			%		During the simulation if $ \bdv $ sees $  k > |\ring_m| $-valid and malicious ring signatures $ \{\sigma_1, \sigma_2, \ldots,\sigma_k\} $ of the message $ m$ signed by $\ring $ whose anonymous keys are $ \{W_1, W_2, \ldots, W_k\} $, respectively , it runs $ \ext(\rsnark,..) $ for each valid malicious signatures $ \sigma_i $(signatures that are not generated by $ \bdv $) and obtains $ \openpk'_i, X'_i \in \ring $. In this case, the one of following two cases must happen:
			%		
			%		\begin{itemize}
				%			\item There exists $ X'\in \ring$ which is an honest key. In this case, $ \bdv  $ runs $ \pi_{dleq} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ and stores $ r V = x^*G + (\openpk - \openpk')K = x^*G + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} G + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%			\item  There exists $ X' \in \ring$ which is the  output of two different signatures.
				%		\end{itemize}
			%		
			%		
			%		During the simulation if $ \bdv $ sees a valid ring signature  $ m, \ring, \sigma = (\pi_{dleq}, \pi_{MT}, C, W) $ where $ X = h^{-1}W \notin \ring$, then $ \bdv $ does the following: It runs the extractor algorithms on $ \pi_{MT} $ i.e., $ \ext(\rsnark,..) $ and obtains $ X' \in \ring $ and $ \openpk' $ where $ C = X' + \openpk' K $ and $ \pi_{dleq} $ i.e., $ \ext(\rcom,..)  \rightarrow x, \openpk$ where $ C = xG + \openpk K$ and $ W = x\hashG(m, \ring)= xhV$. In this case, $ X \neq X' $, so $ \openpk \neq \openpk' $. 
			%				  
			%				  
			%		\begin{itemize}
				%			\item If $ X' $ is honest, then store $ r V = x^*G + (\openpk - \openpk')K = x^*G + b K$ to $DB $. If $ DB $ is empty, rewind $ \adv $ to the beginning of the simulation. If it is not empty i.e., there exists $ \hat{r}X = \hat{x} G + \hat{b}K $, then $ \bdv $ first checks whether $ r = \hat{r} $. If it is the case, it aborts. If it is not the case, it finds the discrete logarithm of $ G=U $ on base $ K $ which is $ t = \frac{\hat{r}^{-1}\hat{b}^*-{r}^{-1}b}{{r}^{-1}\hat{x}-\hat{r}^{-1}\hat{x}} $.  Then, it outputs the CDH of $ U,V $ which is $ tV $. 
				%			We remark that $ \bdv $ aborts after rewinding with a negligible probability because it selects $ r $ randomly.
				%			%TODO exact probability
				%				  	
				%			\item If $ X' $ is  a malicious key, $ \bdv $ runs the extractor algorithm on PoK proof $ \pi_{dl} $ of $ X' $ i.e., $ \ext(\rdl,..,) $ which outputs $ x' $ where $ X' = x'G $. Since $ x' \neq x^* $, $ \bdv  $ has a Pedersen commitment $ C $ with two openings so it can find the discrete logarithm of $ K$ on base $ G $ which is $ t = \frac{x^* - x'}{\openpk' - \openpk^*} $.  In the end, it outputs the CDH of $ X,Y $ which is $ tU $. 
				%
				%		 \end{itemize}
			%		
			%	
			So, the probability of $ \bdv $ solves the CDH problem is equal to the probability of $ \adv $ breaks the forgery or uniqueness in the real protocol. Therefore,  if there exists $ \adv $ that makes $ \simulator$ aborts during the verification, then we can construct an adversary $ \bdv $ that solves the CDH problem except with a negligible probability.
			
			
			\qed	  
		\end{proof}
		
	\end{proof}
\end{proof}
