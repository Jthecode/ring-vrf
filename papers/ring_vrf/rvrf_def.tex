
\section{Ring VRFs}
\label{sec:rvrf_def}

Anonymized VRFs prove a PRF output for some secret key, like VRFs do,
but without identifying the signer beyond revealing the specific PRF output.
Instead, anonymized VRFs prove only an authorization condition for
the secret key.

\def\comring{\ensuremath{\mathsf{comring}}\xspace}
\def\openring{\ensuremath{\mathsf{opring}}\xspace}
\newcommand{\CommitRing}{\primalgo{CommitRing}}
\newcommand{\OpenRing}{\primalgo{OpenRing}}

Among anonymized VRFs, ring VRFs are ring signatures broadly interpreted,
meaning they prove an associated public key lies inside some signer set
commitment \comring which anyone could construct from a set of public keys.

We focus exclusively upon ring VRFs becuase otherwise anonymity and
authorizations conditions come in too many flavours.
In particular, there are group VRFs analogous to group signatures
 \cite{group_sig_survey}, some fairly efficient.
%
We distrust group signatures however because typically some group master
has deanonymization capabilities, giving them only narrow real world uses,
like mailbox spam defense in Pond \cite{pond}.
%
In this vein, attribute based credentials are frequently instantiated
like group signatures, and thus similarly permit deanonymization by some
group master, which makes them similarly unsuitabe for general purpose
privacy.
%
There exist exceptions like credentials using Brands \cite{brands}, and
group signatures with byzantine anonymity \cite{cryptoeprint:2021:181}.

Ring VRFs avoid deanonymization by a group master, and impose coherent
structure upon authorization conditions, with all signers' keys
predating the authorization condition commitment \comring. 
% TODO: Relax in \S\ref{subsec:..}
%
Ring VRF outputs clearly link any two ring VRF signatures with
the same signer and input \msg, so in particular
 ring VRFs with a singleton input domain are linkable ring signatures.

\smallskip

A {\em ring verifiable random function with auxiliary data} (rVRF-AD)
consists of the algorithms of a VRF-AD-KC, except with
 \compk and \openpk renamed to \comring and \openring,
 plus one additional algorithm:
\begin{itemize}
\item $\rVRF.\CommitRing : \ctx \mapsto \comring$ takes a set \ctx of
 public keys and returns a public key set commitment \comring.
\end{itemize}

\def\rSign{\Sign}
\def\rVerify{\Verify}

In this, we have rename the commitment and opening to avoid confusion
when we build a rVRF-AD from a VRF-AD-KC.  This fresh notation leaves
$\rVRF.\KeyGen$ and $\rVRF.\Eval$ untouched, but
 changes the other methods' signatures:
\begin{itemize}
\item $\rVRF.\CommitKey : (\pk,\ctx) \mapsto (\comring,\openring)$
\item $\rVRF.\OpenKey : (\comring,\openring) \mapsto \pk$
\item $\rVRF.\rSign : (\sk,\openring,\msg,\aux) \mapsto \sigma$
\item $\rVRF.\rVerify : (\comring,\msg,\aux,\sigma) \mapsto \Out \, \lor \perp$
\end{itemize}

...


\subsection{rVRF-AC security}

We extend the VRF-AC-KC commitment correctness condition for \CommitRing:

\begin{definition}
We say rVRF satisfies {\em ring commitment correctness} if
commitment correctness holds, and also $\rVRF.\CommitRing$ is 
 compatable with $\rVRF.\CommitKey$ in that
  $\rVRF.\CommitRing(\ctx) = \rVRF.\CommitKey(\pk,\ctx).0$.
\end{definition}

We lack anonymity against full key exposure ala
 \cite[pp. 6 Def. 4]{cryptoeprint:2005:304} of course, due to the VRF output,
but instead demand a weaker anonymity condition similar to
 \cite[pp. 5 Def. 3]{cryptoeprint:2005:304}:

\begin{definition}
We say \rVRF satisfies {\em ring anonymity} if
any PPT adversary $\adv$ has an advantage only
 negligable in $\lambda$ to win the game:
\begin{itemize}
\item[]
 Assume a set $\ctx_0 = \{ \pk_1,\ldots,\pk_n \}$ of public keys from
 distinct key pairs $(\pk_i,\sk_i) \leftarrow \KeyGen$ for $i=1,\ldots,n$ with $n \ge 2$.
 %
 $\adv$ has signing oracles
 $\ora{Sign} : (i,\ctx',\msg',\aux') \mapsto
  \rSign(\sk_i,\CommitKey(\pk_i,\ctx').1,\msg',\aux')$
 for each secret key $\sk_i$ with $i=1,\ldots,n$, and
 their choice of $\ctx',\msg',\aux'$ with $\pk_i \in \ctx'$.
 % as well as the various algorithms. 
 %
 First $\adv$ outputs a ring $\ctx \subset \ctx_0$,
 a message \msg, associated data \aux, and
 indices $i_0,i_1 \le n$ such that $\pk_{i_0},\pk_{i_1} \in \ctx_0$ and 
 $\adv$ never invoked $\ora{Sign}$ on \msg and $i_j$ for $j=0,1$.
 Next the challenger fixes $j=0$ or $j=1$ and gives
  $\adv$ a signature $\sigma = \rSign(\sk_{i_j},\openring,\msg,\aux)$.
 Finally $\adv$ wins by guessing $j$ correctly
\end{itemize}
\end{definition}

We similarly a ring unforgability resembling
 \cite[pp. 7 Def. 7]{cryptoeprint:2005:304}:

\begin{definition}
We say \rVRF satisfies {\em ring unforgability} if
any PPT adversary $\adv$ has an advantage only
 negligable in $\lambda$ to win the game:
\begin{itemize}
\item[]
 Assume a set $\ctx_0 = \{ \pk_1,\ldots,\pk_n \}$ of public keys from
 distinct key pairs $(\pk_i,\sk_i) \leftarrow \KeyGen$ for $i=1,\ldots,n$ with $n \ge 2$.
 %
 $\adv$ has signing oracles
 $\ora{Sign} : (i,\ctx',\msg',\aux') \mapsto
  \rSign(\sk_i,\CommitKey(\pk_i,\ctx').1,\msg',\aux')$
 for each secret key $\sk_i$ with $i=1,\ldots,n$, and
  their choice of $\ctx',\msg',\aux'$ with $\pk_i \in \ctx'$.
 % as well as the various algorithms. 
 %
 Now $\adv$ wins by outputing a valid signature $\sigma$ for
 a ring $\ctx \subset \ctx_0$, a message \msg, and associated data \aux
 such that
 $\adv$ never invoked $\ora{Sign}$ on $\msg,\aux$ and $i$ with $\pk_i \in \ctx$.
\end{itemize}
\end{definition}

We also need a uniqueness condition that limits even adersaries who know the secret key.

% \begin{definition}
% We say \rVRF satisfies {\em ring uniqueness} if
% any PPT adversary $\adv$ has an advantage only
%  negligable in $\lambda$ to 
% produces a ring $\ctx$, input $\msg$, 
% and various $\aux_i,\sigma_i$ with more than $|\ctx|$
% many verifying outputs $\Out_i = \Verify(\CommitRing(\ctx),\msg,\aux_i,\sigma_i)$.
% \end{definition}

\begin{definition}
We say \rVRF satisfies {\em ring unforgability} if
any PPT adversary $\adv$ who produces
 a ring $\ctx$, input $\msg$,  and various $\aux_i,\sigma_i$
cannot produce more than $|\ctx|$ many verifying outputs
$\Out_i = \Verify(\CommitRing(\ctx),\msg,\aux_i,\sigma_i)$,
 except with odds negligible in $\lambda$.
\end{definition}

Any ring VRF becomes a non-anonymized VRF whenever
 the ring becomes a singleton $\ctx = \{ \pk \}$ of course.
In doing so this, ring uniqueness reduces to uniqueness for VRF-AC,
meaning our uniqueness with only a trivial key commitment,
but \ThinVRF is faster and simpler.

We reuse the VRF-AC-KC pseudorandomness definition for ring VRFs
because pseudorandomness is strongest for singleton rings, i.e. $|\ctx| = 1$.


\subsection{rVRF-AC instantiation}

We instantiate a rVRF-AD from a hiding VRF-AD-KC like \PedVRF plus
a ring commitment scheme
 $\rVRF.\{ \CommitRing, \CommitKey, \OpenKey \}$
for which some zero-knowledge ring membership proof handles both
 $\PedVRF.\OpenKey$ and $\rVRF.\OpenKey$
efficently.

\newcommand\piring{\ensuremath{\pi_{\mathtt{ring}}}\xspace}

\begin{itemize}
\item $\rVRF.\rSign : (\sk,\openring,\msg,\aux) \mapsto \sigma$ takes
 a secret key \sk, a ring opening \openring, a message \msg, and auxiliary data \aux, and then \\
 \begin{enumerate}
 \item computes the ring membership proof $\piring$ and associated \openpk,
  $$ \piring = \NIZK \Setst{ \compk, \comring }{
  \exists \openpk,\openring \textrm{\ s.t.\ } 
  \genfrac{}{}{0pt}{}{\PedVRF.\OpenKey(\compk,\openpk) \quad}{\,\, = \rVRF.\OpenKey(\comring,\openring)}
  } $$
 \item computes the VRF-AC-KC signature
  $\sigma = \PedVRF.\Sign(\sk,\openpk,\msg,\aux \doubleplus \compk \doubleplus \piring)$, and finally
 \item returns the ring VRF signature $\rho = (\compk,\piring,\sigma)$.
 \end{enumerate}
\item $\rVRF.\rVerify$ takes $(\comring,\msg,\aux,\rho)$,
 parses $\rho$ as $(\compk,\piring,\sigma,)$,  and then returns
 $$ \PedVRF.\Verify(\compk,\msg,\aux \doubleplus \compk \doubleplus \piring,\sigma) $$
 iff $\NIZK.\Verify(\piring,\compk,\comring)$ succeeds. 
\end{itemize}

% \noindent
In this, we tie $\sigma$ to $\piring$ by expanding $\sigma$'s auxiliary data with $\piring$.

\smallskip

We now prove security of \rVRF using that
\begin{itemize}
\item \PedVRF is a secure hiding VRF-AC-KC, and that
\item our ring commitment scheme satisfies ring commitment correctness.
\end{itemize}

Pseudorandomness holds by pseudorandomness of \PedVRF from
 Proposition \ref{prop:pedersen_vrf}.

\begin{proposition}\label{prop:pedersen_rvrf}
$\rVRF$ satisfies ring uniqueness and ring unforgability.
\end{proposition}

\begin{proof}[Proof sketch]
???
\end{proof}


TODO:  Should we give an abstract pure NIZK instaniation here?  I think later probably.


\subsection{UC}

TODO: Should we gives Handan's UC functionality or similar here? 




\endinput




\noindent 
\begin{itemize}

\item {\em Ring } - 
  Assuming ,
 a PPT adversary $\adv$ cannot distinguish a random function from
  any evaluation map $F_{\sk_i} : \msg \mapsto \Eval(\sk,\msg)$,
 even given $\ctx_0 = \{ \pk_1,\ldots,\pk_i \}$ and
  chosen-message queries to $\rVRF.\rSign(\sk_i,\openring)$,
  except with odds negligible in $\lambda$.
\end{itemize}


\begin{definition}
We say \rVRF satisfies {\em ring pseudorandomness} if 
any PPT adversary $\adv$ has only a negigable advantage in $\lambda$
in this chosen-message game:
\begin{itemize}
 \item Frist, a challenger
  generates keypairs $(\pk_1,\sk_1),\ldots,(\pk_1,\sk_1) \leftarrow \KeyGen$ and
  defines a signing oracles $\ora{Sign}_i$ given by
  $(\compk,\openpk,\msg,\aux) \mapsto \Sign(\sk_i,\openpk,\msg,\aux)$,
   except it logs $\msg$ and aborts if $\pk_i \ne \OpenKey(\compk,\openpk)$.
 \item Next $\adv$ recieves the $\pk_i$, repeatedly queries $\ora{Sign}_i $,
  and produces $\compk,\openpk,\msg,\aux$. 
 \item If $\adv$ never queried $\ora{Sign}(\cdot,\cdot,\msg,\cdot)$ then
  $\adv$ wins by distinguishing $\Eval(\sk,\msg)$ from random value.
\end{itemize}
\end{definition}


