
\section{Our Second Ring VRF Construction based on $ \ZKCont $}

\label{subsec:rvrf_faster}
We enhance our construction from Section \ref{sec:pederson_vrf} by incorporating $ \ZKCont $. This protocol leverages the rerandomization properties of $ \ZKCont $, allowing a signer to generate a signature for a different $ \msg $ within the same ring without having to recompute the most expensive part of the NIZK proof related to the key membership of the ring. $\CommitRing, \OpenRing $ works as in the first ring VRF protocol and $ \KeyGen$ works as in the alternative-1 of our first protocol.
\begin{itemize}
	\item $ \rVRF.\Setup(1^\secparam)   $ outputs $ \pprvrf = (crs_{\relinner}, \crsnark,  \pp_{\relinner}, (p, \grE,\genG, \genB), \F_p) $ where $ \crs_{\relinner}$ and $\pp_{\relinner} $ are generated by $ \ZKCont.\Setup(1^\secparam, \relinner) $ and $ \crsnark $ is generated by $ \NARK_{\relcomring}.\Setup(1^\secparam) $.
	
	\item $\rVRF.\rSign(\sk,\comring, \openring,\msg,\aux) $ computes $ \PreOut = \sk H_\grE(\msg) $, lets $ \Out = H(\msg, \PreOut) $. Then runs $ \NIZK_{\relrvrf}.\Prove(\comring,\PreOut, \msg, \Out; \sk,\openring)\rightarrow \pi_{rvrf}$ where
	
\eprint{$$ \relrvrf = \Setst{
		\begin{aligned}
			&\comring, (\PreOut,\msg, \Out); \\
			&x,r, \openring
		\end{aligned}
	}{
		\begin{aligned}
			& (\comring,x;r,\openring) \in \relinner, \\
			& (\PreOut, \msg, \Out; \sk) \in \relout
	\end{aligned}	}$$}
{\begin{footnotesize}
		$$ \relrvrf = \Setst{
			\begin{aligned}
				&\comring, (\PreOut,\msg, \Out); \\
				&x,r, \openring
			\end{aligned}
		}{
			\begin{aligned}
				& (\comring,x;r,\openring) \in \relinner, \\
				& (\PreOut, \msg, \Out; x) \in \relout
		\end{aligned}} \text{ and}$$
	\end{footnotesize}
}   
\eprint{
	and
	$$ \relinner = \Setst{ (\comring, \sk ; r,\openring) }{
		\begin{aligned}
			&	\pk = \rVRF.\OpenRing(\comring,\openring), \\
			& 	x = \mathsf{Com}.\mathsf{Open}(\pk;x,r) 
		\end{aligned}	
	},$$
	$$\relout = \{(\PreOut, \msg,\Out; \sk): \PreOut = \sk H_\grE(\msg), \Out = H(\msg,\PreOut)\}$$
}{
\begin{footnotesize}
	$$ \relinner = \Setst{ (\comring, x ; r,\openring) }{
		\begin{aligned}
			&	\pk = \rVRF.\OpenRing(\comring,\openring), \\
			& 	x = \mathsf{Com}.\mathsf{Open}(\pk;x, r) 
		\end{aligned}	
	},$$
	$$\relout = \{((\PreOut, \msg,\Out),\sk; \perp): \PreOut = \sk H_\grE(\msg), \Out = H(\msg,\PreOut)\}$$
\end{footnotesize}
}
	
	We instantiate $ \NIZK_{\relrvrf}.\Prove $ as described in Section \ref{sec:nizkR} where $ \relone = \relinner $ and $ \reltwo' = \rel_{eval} $ and $\baseR = \relrvrf$ . \eprint{It works as follows: It runs $ \ZKCont.\Preprove(crs, \comring,\sk,(r,\openring),\relinner) $ and obtains $ \compk', \pi' , \openpk' = 0$. Then, it runs $ \ZKCont.\Reprove(crs, X',\pi',\openpk',\relinner) $ and obtains $ (\compk, \pi_1, \openpk) $. Finally, it lets $ \PreOut = \sk H_\grE(\msg) $ and runs $ \NIZK_{\rel_{eval}}.\Prove(\compk, \PreOut, \msg;\sk,\openpk,\msg) \rightarrow \pi_2 $ as described in Section $ \ref{sec:pederson_vrf} $ with $\aux' = \tmpaux$ .}{}
	In the end, it returns the ring signature $ \sigma = (\compk, \pi_{\mathtt{inner}},\comring, \pieval, \PreOut) $ where $ \compk,\pi_{\mathtt{inner}}, \openpk $ generated by $\ZKCont_{\relinner}.\Prove $ and $ \pieval $ is generated by $ \NIZK_{\rel_{eval}}.\Prove $. Here, $ \compk $ is a Pedersen commitment to $ x $ as described in $ \PedVRF $.
	
	\item  $\rVRF.\rVerify : (\comring,\msg,\aux,\sigma) \mapsto (1,\Out) \,\, \lor (0,\perp)$ \,
	it parses $\sigma$ as $(\compk, \pi_{\mathtt{inner}},\comring, \pieval, \PreOut$ and runs  $\NIZK_{\relrvrf}.\Verify(\comring, \PreOut, \msg, \Out; \pieval,\compk, \pi_{\mathtt{inner}})$  \eprint{i.e., runs $ \ZKCont.\Verify(crs, \comring, \compk,\pi_1,\relinner) $ and $ \NIZK_{\rel_{eval}}.\Verify((\compk, (\PreOut, \msg, \Out)), \pi_2) $}{as described in Section \ref{sec:nizkR} }. If all verify, it outputs $ (1,\Out = H(\msg,\PreOut)) $. Otherwise, it returns $ (0,\perp) $.
\end{itemize}




\begin{theorem}\label{thm:rvrfspecial}
	Our specialized $ \rVRF $   realizes $ \fgvrf $ running $ \Gen_{sign} $ (Algorithm \ref{alg:gensignSG}) \cite{canetti1,canetti2} in the random oracle model assuming that $\ZKCont $ is zero-knowledge and knowledge sound as defined in Definition \ref{def:zk_cont} and $ \NIZK_{\mathcal{R}_{eval}} $ is zero-knowledge and knowledge sound, $ \NARK_{\relcomring} $ is knowledge sound, the DDH problem are hard in $ \grE  $ \eprint{(so the CDH problem is hard as well)}{} and the commitment scheme $ \mathsf{Com} $ is binding and perfectly hiding. 
\end{theorem}
\begin{algorithm}
	\eprint{}{\scriptsize}
	\caption{$\Gen_{sign}(\ring, \sk= (x,r),\pk,\aux,\msg)$}
	\label{alg:gensignSG}	 	
	\begin{algorithmic}[1]
		\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring, \pk) $
		\State $ \compk', \pi', \openpk' \leftarrow \ZKCont.\Preprove(crs, \comring,\sk,(r,\openring)) $
		\State $ \compk, \pi_{\mathtt{inner}}, \openpk \leftarrow \ZKCont\Reprove(crs, \compk',\pi',\openpk') $ 
		\State $ c,s_1, s_2 \leftsample \F_p $
		\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$		
		\State\Return$ \sigma = (\compk, \pi_{\mathtt{inner}},\comring, \pieval) $
	\end{algorithmic}
	
\end{algorithm}

\noindent \textit{Proof Sketch:}  The security proof follows very similar to our first construction.
We construct the same $ \simulator $ described in the proof of Theorem \ref{thm:firstprotocol} because in the second construction, random oracles in this construction are the same as in the first contruction. Then, we use the result of Lemma \ref{lem:anonymity} because $ \PreOut $ is the same. The only slight difference is in Lemma \ref{lem:simulation-ind} since $ \Gen_{sign} $ is different than Algorithm \ref{alg:gensign}. There, we run the simulator and extractor of $ \NIZK_{\relrvrf} $  instead of extractors of  $ \NIZK_{\Rring} $ and $ \NIZK_{\rel_{eval}} $. See Appendix \ref{ap:secondprotocolproof} for more details.



%requires two scalar multiplications on $\grE_1$
%and two on the same or faster $\grE'$,
%so together with $\SpecialG.\Reprove$ costing four scalar multiplications
%on $\grE_1$ and two on $\grE_2$, our amortised prover time
%runs faster than 12 scalar multiplications on typical $\grE_1$ curves. 
%We expect the three pairings dominate verifier time, but
%verifiers also need five scalar multiplications on $\grE_1$.

%TODO WHAT DOES IT MEAN
%Importantly, our fast ring VRF's amortised prover time now rivals
%group signature schemes' performance \cite{group_sig_survey}.
%We hope this ends the temptation to deploy group signature like
% constructions where the deanonymisation vectors matter. 
