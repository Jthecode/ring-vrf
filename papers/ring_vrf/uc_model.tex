\newcommand{\Gen}{\ensuremath{\mathsf{Gen}}}

\newcommand{\anonymouskeymap}{\ensuremath{\mathtt{anonymous\_key\_map}}}
\newcommand{\anonymouskeylist}{\mathcal{W}}
\renewcommand{\sim}{\simulator}
\newcounter{FunCond}


\section{Security Model  of Ring Verifiable Random Function}

In this section, we define formally a ring VRF scheme and model its security in the UC model.

\begin{definition}[Ring VRF] \label{def:ringVRF}	A ring VRF scheme is defined with public parameters $ pp $ generated by a setup algorithm $ \rVRF.\Setup(1^\secparam) $ and with the following  algorithms.
	
	\begin{itemize}
		\item $ \rVRF.\KeyGen(pp) \rightarrow (\sk,\pk)$: It is a PPT algorithm that generates a secret key and public key pair $ (\sk,\pk) $ given input $ pp $.
		\item $ \rVRF.\Eval(\sk_i, \msg) \rightarrow y$: It is a deterministic polynomial time algorithm that outputs an evaluation value $ y \in \setsym{S}_{eval}$ given input $ \sk_i $ and $ \msg $. Here, $ \setsym{S}_{eval} $ is the domain  of  evaluation values and defined in $ pp $.
	\end{itemize}
	The following algorithms need an input $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$ that we call ring:
	\begin{itemize}
		\item $ \rVRF.\CommitRing(\ring, \pk)  \rightarrow (\comring, \openring)$: It is a PPT algorithm that outputs a commitment of $ \ring $ with the opening $ \openring $ given input  $ \ring $ and $ \pk \in \ring $.
		\item $ \rVRF.\OpenRing(\comring,\openring) \rightarrow \pk $: It is a PPT algorithm that outputs a public key $ \pk  $ given commitment $ \comring $ and an opening $ \openring $ of $\comring$ to $\pk$.
		\item $ \rVRF.\Sign(\sk_i, \comring,\openring, \msg, \aux)\rightarrow \sigma$: It is a PPT algorithm that outputs a ring signature  $\sigma $  that signs a message $ \msg \in \{0,1\}^* $ and an associated data $ \aux \in \{0,1\}^*$ with $ \sk_i$ for $ \comring $ if .
		\item $ \rVRF.\Verify(\comring,\msg,\aux,\sigma) \rightarrow  (b, y)$: It is a deterministic polynomial time algorithm that outputs  $ b \in \{0,1\} $ and $ y \in\setsym{S}_{eval}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
	\end{itemize}
	We note that  all algorithms above have $ pp $ as part of their input even if we do not always explicitly write it.
\end{definition}


We note that $ \rVRF.\CommitRing $ and $  \rVRF.\OpenRing $ are optional algorithms of a ring VRF scheme. If they are not defined, we should let $ \comring = \ring $ and $ \openring  = \pk$. $ \rVRF.\CommitRing $ and $  \rVRF.\OpenRing $ are functional for a succinct verification process in the case of a large ring.

The security properties that we want to achieve in a ring VRF scheme are informally as follows: \emph{correctness} meaning that when an honest signer with key $ (\sk_i,\pk_i) $ outputs $ \sigma $ by running $ \rVRF.\Sign(\sk_i, \comring,\openring, \msg, \aux) $, $ \rVRF.\Verify(\comring,\msg,\aux,\sigma)  $ must output $ b =1 $ and $ y $ which is equal to $ \rVRF.\Eval(\sk_i, \msg) $ if and only if $ \rVRF.\OpenRing(\comring,\openring) \rightarrow \pk_i \in \ring$, \emph{randomness} meaning that an evaluation value is random and independent from the message and the public key, \emph{determinism} meaning that $ \rVRF.\Eval $ is deterministic, \emph{anonymity} meaning that $ \rVRF.\Sign $ does not give any information about its signer, \emph{unforgeability} meaning that an adversary should not be able to forge a ring signature and \emph{uniqueness} meaning that number of verified evaluation values should not be more than the number of the keys in the ring.


We could define all these security properties formally in the standard model but this might cause composability issues when the ring VRF protocol composed with other protocols. Considering the applications of ring VRF protocol, we want to achieve stronger security guarantees in different environments. Therefore, we define the security of a ring VRF scheme in the UC model in Section \ref{subsec:uc_model}. 

One can consider a ring VRF scheme is a combination of a VRF scheme and a ring signature scheme where $ \rVRF.\Eval $ is similar to $ \Eval $ algorithm of a VRF scheme and $ \rVRF.\Sign $ is similar to $ \Sign $ algorithm of a ring signature scheme. The  subtle difference is in $ \rVRF.\Verify $ that works  similar to both $ \Verify $ of ring signature and VRF schemes.  $ \rVRF.\Verify $ does not need the signer's public key to verify a ring signature as in a ring signature scheme but it outputs the signer's evaluation value for every verified signature. If $ y $ is generated independent from the signer's key, $ \rVRF.\Verify(\ring,\msg,\aux,\sigma) $ does not reveal any identity of the signer except that the signer's key is in the ring.


We remark that the output of $ \rVRF.\Eval $ does not depend on a ring. Therefore, if a signer $ \user $ with key $ \sk $ signs a message $ \msg $ for $ \ring $ and later wants to reveal that it signed $ \msg $  for $ \ring $, $ \user $ should sign $ \msg $ with another ring $ \{\sk\} $. Since the verification of both signatures outputs the same evaluation value, the verifier can be convinced that $ \user $ signed the both signatures. Hence, a ring VRF scheme can link the identities of the signers if it is necessary.




\subsection{Ring Verifiable Random Function in the UC Model}
\label{subsec:uc_model}
We introduce a ring VRF functionality $ \fgvrf $ to model execution of a ring VRF protocol in the ideal world. In other words, we define a ring VRF protocol in the case of having a trusted entity $ \fgvrf $. There are many straightforward ways of defining a ring VRF protocol in the ideal world satisfying the desired security properties. However, defining simple and intuitive functionality while being as expressive and realizable in the real world execution is usually at odds \cite{canetti1}. Therefore, we have a lengthy $ \fgvrf $ (See Figure \ref{f:gvrf}) which satisfies the security properties that we expect from a ring VRF scheme and at the same time faithful to the reality as possible. For the sake of clarity and accessibility, we split each execution part of $ \fgvrf $ while we introduce our functionality. The composition of all parts is in Figure \ref{f:gvrf} in Appendix A. We first describe how $  \fgvrf $ works and then show which security properties it achieves.


$ \fgvrf $ has tables to store the data generated from the requests from honest parties and the adversary $ \simulator $. The table $ \vklist $  keeps the keys of parties. The other table  $ \anonymouskeymap $ stores an anonymous key that corresponds to an evaluation input  of a party with a key $ \pk $. We note that the real execution of a ring VRF (Definition \ref{def:ringVRF}) does not have a concept of an anonymous key but $ \fgvrf $ needs this internally to execute the verification of a ring signature. Related to anonymous keys, $ \fgvrf $ also stores  all  anonymous keys of all malicious  signatures  for a ring and input in a table $ \anonymouskeylist $. Finally, $ \fgvrf $ stores the evaluations values of a party in $ \evaluationslist $. In a nutshell,  given $ \pk $
and $ \msg $, $ \fgvrf $  generates an anonymous key $ W $ as explained below and  sets $ \anonymouskeymap[\msg,W]  $ to $ \pk $. Then, it generates an evaluation value $ y $ as explained below and sets $ \evaluationslist[\msg,W]  $ to $ y $. In short, given honestly generated secret, public key pair $ (\sk,\pk) $ in the real world, the algorithm
$ \rVRF.\Eval(\sk,\msg) $  that outputs evaluation value corresponds to generating an anonymous key $ W $ for $ \pk, \msg $ and obtaining the evaluation value stored in $ \evaluationslist[\msg,W] $ in the ideal world. The functionality of all these tables and anonymous key will be more clear while we explain $ \fgvrf $ in detail. $ \fgvrf $ consists of the following execution parts.



\paragraph{Key Generation:}  Whenever an honest party requests  a key, $ \fgvrf $ obtains a key pair $ (x, \pk) $ from $ \simulator $. $ \fgvrf $ stores them if they have not been recorded. If it is the case, $ \fgvrf $ gives only $ \pk $ to the honest party. $ \fgvrf $ will later use $ x $ during signature generation of this honest party. One can imagine $ x $ as a secret key and $ \pk $ as a public key. We note that it is not a problem in the ideal model that the adversary generates the secret key because a signature generated by an honest key can be valid if and only if the corresponding honest party requests it as it is guaranteed during the verification process of $ \fgvrf $.

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Key Generation.]} upon receiving a message $(\oramsg{keygen}, \sid)$ from a party $\user_i$, send $(\oramsg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
	Upon receiving a message $(\oramsg{verificationkey}, \sid, x,\pk)$ from $\simulator$, verify that $x,\pk$ has not been recorded before for $ \sid $ i.e., there exists no $ (x', \pk') $ in $ \vklist $ such that $ x' = x $ or $ \pk' = \pk $. If it is the case, store in the table $\vklist$, under $\user_i$, the value $x,\pk$ and return $(\oramsg{verificationkey}, \sid, \pk)$ to $ \user_i$.
\end{tcolorbox}

\paragraph{Corruption:} $ \simulator $ can corrupt any honest party at any time.  So, $ \fgvrf $ provides security against an adaptive adversary.

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Corruption:] } 
	upon receiving $ (\oramsg{corrupt}, \sid, \user_i) $ from $ \simulator $, remove $ (x_i,\pk_i) $ from $ \vklist[\user_i] $ and store them to $ \vklist $ under $ \sim $. Return $ (\oramsg{corrupted}, \sid,\user_i) $.
\end{tcolorbox}

\paragraph{Malicious Ring VRF Evaluation:} This part of $ \fgvrf $ is for $ \simulator $ in case of $ \simulator $ wants to evaluate an input for a malicious key. For this,  it should provide to $ \fgvrf $ an input $ \msg $, a malicious key $ \pk $ and an anonymous key $ W $.  Then, $ \fgvrf $ evaluates  $ \msg $ with $ \pk $ if an anonymous key $ W' \neq W$  is not assigned to $ \msg $ and $ \pk $ before.  If it is the case, it returns an evaluation value $ \evaluationslist[\msg, W] $ which is selected randomly. The reason of conditioning on a unique anonymous key for $ \msg $ and $ \pk $ is to prevent $ \simulator $ to obtain more than one evaluation values corresponding to $ \msg $ and $ \pk $. This is necessary to have a uniqueness property.
We remark that it is possible that $ \simulator $ obtains the same evaluation value of $ \msg $ with two different malicious public keys $ \pk_i, \pk_j $ by sending $ (\oramsg{eval}, \sid, \pk_i, W, \msg) $ and $(\oramsg{eval}, \sid, \pk_j, W, \msg)$. However, this does not break the uniqueness property.

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Malicious Ring VRF Evaluation.]}  upon receiving a message $(\oramsg{eval}, \sid, \pk_i, W, \msg)$ from $\sim$, if $ \pk_i $ is recorded under an honest party's identity or if there exists $ W'\neq W $ where $ \anonymouskeymap[\msg,W'] = \pk_i $, ignore the request.
	Otherwise, record in the table $\vklist$ the value $\pk_i$ under $\simulator$ if $ \pk_i $ is not in $ \vklist $.
	
	If  $\anonymouskeymap[\msg,W]  $ is not defined before, set $ \anonymouskeymap[\msg,W] = \pk_i $ and let   $y \leftsample \setsym{S}_{eval}$ and set $ \evaluationslist[\msg, W] = y$.
	
	In any case (except ignoring), obtain $ y = \evaluationslist[\msg, W] $ and return $(\oramsg{evaluated}, \sid,  \msg, \pk_i,W, y)$ to $ \user_i $.
\end{tcolorbox}

We remark that once $ \simulator $ obtains an anonymous key $ W $ of  $ \msg $  and honest key $ \pk $,  $ \simulator $ can learn the  evaluation of  $ \msg $ with $ \pk $ without knowing the $ \pk $ via malicious ring VRF evaluation i.e., send the message $ (\oramsg{eval}, \sid, \pk_i,W,\msg) $ where $ \pk_i $ is a malicious verification key. Here, if $ W $ is an anonymous key of $ \msg, \pk  $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ even if $ \pk \neq \pk_i $. We note that this leakage does not contradicts the desired security properties and helps us to prove our ring VRF protocol realizes $ \fgvrf $.  


\paragraph{Honest Ring VRF Signature and Evaluation:} This part of $ \fgvrf $ works for honest parties who evaluate an input and generate a ring signature for a ring. An honest party $ \user_i $ should provide to $ \fgvrf $ a ring consisting of set of public keys, its own public key $ \pk_i $, optionally an associated data $ \aux $ and a message $ \msg $ to be signed and evaluated. Then, $ \fgvrf $ generates the evaluation value of $ \msg $ and $ \pk_i $ and signs $ \msg $ with associated data $ \aux $ for given $ \ring $ if $ \pk_i \in \ring $. The evaluation for honest parties works as follows: If $ \fgvrf $ does not select an anonymous key for $ \msg $ and $ \pk_i $ before, it samples randomly an anonymous key $ W $ and samples randomly the evaluation value $ y $. The ring signature generation works as follows:  $ \fgvrf $ runs a PPT algorithm $ \Gen_{sign}(\ring, W, x,\pk,\aux,\msg) $ and obtains the ring signature $ \sigma $. It records $  [\msg,\aux, W, \ring,\sigma, 1]  $ for the verification process where $ 1 $ indicates that $ \sigma  $ is a valid ring signature of $ \msg $ and $ \aux $ generated for $ \ring $ with the anonymous key $ W $.

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Honest Ring VRF Signature and Evaluation.]} upon receiving a message $(\oramsg{sign}, \sid, \ring, \pk_i,\aux, \msg)$ from $\user_i$, verify that $\pk_i \in \ring$ and that there exists a public key $\pk_i$ associated to $\user_i$ in $ \vklist $. If it is not the case, just ignore the request. 	
	If there exists no $ W' $ such that $ \anonymouskeymap[\msg,W'] =  \pk_i $, let $ W \leftsample \setsym{S}_W $ and let $y \leftsample \setsym{S}_{eval}$. If there exists $ W $ where $ \anonymouskeymap[\msg,W] $ is defined, then abort. Here, $ \setsym{S}_W $ is the domain of honest anonymous keys. Otherwise, set $ \anonymouskeymap[\msg,W] = \pk_i $ and set $ \evaluationslist[\msg, W] = y$.
	
	In any case (except ignoring and aborting), obtain $ W, y $ where $ \anonymouskeymap[\msg,W] =\pk_i $ and $ \evaluationslist[\msg, W] = y$  and run  $ \Gen_{sign}(\ring, W,x,\pk,\aux,\msg) \rightarrow \sigma $. 
	%Verify that $ [\msg,\aux, W,\ring, \sigma, 0] $ is not recorded. If it is recorded, abort. Otherwise,
	Record $ [\msg,\aux, W, \ring,\sigma, 1] $. Return $(\oramsg{signature}, \sid, \ring,W,\aux,\msg, y, \sigma )$ to $\user_i$.
\end{tcolorbox}


\paragraph{Malicious Requests of  Signatures:} If $ \simulator $ provides $ \ring,W, \aux, \msg$, $ \simulator $  obtains all valid and stored ring signatures of $ \msg $ and $ \aux $ generated for $ \ring $ with an anonymous key $ W $.  

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Malicious Requests of  Signatures.]} upon receiving a message $ (\oramsg{signs}, \sid, \ring, W, \aux,\msg) $ from $ \simulator $, obtain all existing valid signatures $ \sigma $ such that $ [\msg, \aux,W,\ring,\sigma, 1] $ is recorded and add them in a list $ \lst_{\sigma} $. 	Return $ (\oramsg{signs}, \sid, \ring, W,\aux,\msg, \lst_{\sigma})  $ to $ \simulator $.
\end{tcolorbox}


\paragraph{Ring VRF Verification:} This part of $ \fgvrf $ is to check whether a ring signature of $ \sigma $ signs $ \msg $ and $ \aux $ for $ \ring $ with anonymous key $ W $. This part should correspond to $ \rVRF.\Verify $ in the real world ring VRF protocol. Therefore,
$ \fgvrf $ first checks various conditions to decide whether the signature is valid. If the signature is verified, $ \fgvrf $ outputs $ b = 1 $ and $ y = \evaluationslist[\msg, W] $. Otherwise, it outputs $ b = 0 $ and $ y = \perp $. 


For the verification of the signature, $ \fgvrf $  first checks its records to see whether this signature is verified or unverified in its records i.e., checks  whether $ [\msg,\aux,W,\ring,\sigma, b'] $ is recorded (See  C\ref{cond:consistency}). If it is recorded, $ \fgvrf $ lets  $ b = b' $ to be consistent. Otherwise, it checks whether $ W $ is an anonymous key of an honest party generated for $ \msg $ (See C\ref{cond:differentsignature}). If it is the case, $ \fgvrf $ checks  its records whether this honest party requested signing  $ \msg $ and $ \aux $ for $ \ring $.  If there exists such record i.e., $ [\msg, \aux, W, \ring, ., 1] $, it stores the new signature $ \sigma $ as a valid signature in its records and lets $ b = 1 $. We remark that $ \simulator $ can create arbitrary verified signatures that sign any $ \msg $ and $ \aux $ for $ \ring $ with $ W $ once the honest party owning $ W $ has requested signing $ \msg $ and $ \aux $ for $ \ring $. This does not break the forgeability property because the honest party has already signed for it. 
If none of the above conditions (C\ref{cond:consistency} and C\ref{cond:differentsignature}) holds, it means that $ \sigma $ could be a signature generated for a malicious party. Therefore, $ \fgvrf $ asks about it to $ \simulator $ and $ \simulator $ replies with an indicator $ b_\simulator $ showing that $ \sigma  $ is valid or not and a public key $ \pk_\simulator $. Then, $ \fgvrf $ checks various conditions to prevent $ \simulator $ forging and violating the uniqueness. To prevent forging, it lets  directly $ b = 0 $, if $ \pk_\simulator $ is a key of an honest party. If $ \pk_\simulator $ is not an honest key, then $ \fgvrf $ checks its table $ \anonymouskeylist[\msg,\ring] $ which stores the anonymous keys of valid malicious signatures of $ \msg $ for $ \ring $. If the number of anonymous keys in $ \anonymouskeylist[\msg,\ring] $ is greater than or equal to the number of malicious keys in $ \ring $, then $ \fgvrf $ invalidates $ \sigma $ by letting $ b = 0 $. This condition guarantees  uniqueness meaning that the number of verifying evaluation values that $ \sim $ can generate for $ \msg, \ring $ is at most the  number of malicious keys in $ \ring $. If the number of malicious anonymous keys of valid signatures does not exceed the number of malicious keys in $ \ring $, then $ \fgvrf $ checks whether $ W $ is a unique anonymous key assigned to $ \msg,\pk_\simulator $ as in the ``Malicious Ring VRF Evaluation''. If $ W $ is unique then $ \fgvrf $ lets $ b = b_\simulator $.

After deciding $ b $, $ \fgvrf $ records it as $ [\msg, \aux, W,\ring,\sigma,b] $ to be able to reply with the same $ b $ for the same verification query later. If $ b = 1 $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ as well.

\begin{tcolorbox}[left=2pt,right=2pt]
	\textbf{[Ring VRF Verification.]} upon receiving a message $(\oramsg{verify}, \sid, \ring,W, \aux, \msg, \sigma)$ from a party, do the following: 
	% \begin{list}[label={{C}}{{\arabic*}}, start = 1]
		% https://texblog.net/help/latex/ltx-260.html
		
		\begin{list}{\hspace*{1pt} C\arabic{FunCond}}{\usecounter{FunCond}\setlength\leftmargin{0.15in}}
			\item If there exits a record $ [\msg,\aux,W,\ring,\sigma, b'] $, set $ b = b' $. 
			%(This condition guarantees the completeness and consistency.)
			%					\item Else if $ \pk  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pk) $ and there exists no record $ [m, \ring, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= 0  $.
			%					(This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \ring $, then the verification fails.)\label{cond:forgery}
			
			%\item Else if there exists a record  such as $ [m,W,\ring,\sigma, b'] $, set $ b = b' $. (This condition guarantees consistency meaning that all identical verification requests will output the same $ b $) 
			\label{cond:consistency}
			\item Else if $ \anonymouskeymap[\msg,W]  $ is an honest verification key and  there exists a record $ [\msg,\aux, W,\ring, \sigma', 1] $ for any $ \sigma' $, then let $ b=1 $ and record $ [\msg,\aux, W,\ring,\sigma, 1] $. 
			%(This condition guarantees that if $ \msg $ is signed by an honest party for the ring $ \ring $ at some point, then the signature is $ \sigma' \neq \sigma $ which is generated by the adversary is valid) 
			\label{cond:differentsignature}
			
			\item \label{cond:malicioussignature}Else relay the message $(\oramsg{verify}, \sid, \ring,W,\aux, \msg, \sigma)$ to $ \simulator $ and receive back the message $(\oramsg{verified}, \sid, \ring,W,\aux, \msg, \sigma, b_{\simulator}, \pk_\simulator)$.  Then check the following:
			
			\begin{enumerate}
				\item If   $ \pk_\simulator $ is an honest verification key, set $ b = 0 $.
				% (This condition guarantees unforgeability meaning that if an honest party never signs a message $ \msg$ for a ring $ \ring $)\label{cond:forgery}
				
				\item Else if $ W \notin \anonymouskeylist[\msg,\ring] $ and $ |\anonymouskeylist[\msg, \ring]| \geq |\ring_{mal}| $ where $ \ring_{mal} $ is a set of malicious keys in $ \ring $, set $ b = 0 $.
				%(This condition guarantees  uniqueness meaning that the number of verifying outputs that $ \sim $ can generate for $ \msg, \ring $ is at most the  number of malicious keys in $ \ring $.)
				\label{cond:uniqueness}.
				%\item \label{cond:forgerymalicious}Else if there exists $ \anonymouskeymap[W] = (m', \ring',.)  $ where $ (m', \ring') \neq (m, \ring) $ or $ \counter[m, \ring] > |\ring_m| $ where $ \ring_m $ is a set of keys in $ \ring $ which are not honest or $ b_{\simulator} = 0 $ or $ \pk_\simulator $ belongs to an honest party, set $ b = 0 $ and record $ [m, \ring,W,\sigma, 0] $. (This condition guarantees that if $ W $ is an anonymous key of a different message and ring or the number of anonymous keys of malicious parties in $ \ring $ is more than their number or     $ \simulator $ does not verify $ \sigma $, then the verification fails.)
				
				\item Else if there exists $ W' \neq W $ where  $ \anonymouskeymap[\msg,W'] = \pk_\simulator $, set $ b = 0 $. \label{cond:differentWforsamepk} 
				%(This condition guarantees that there exists a unique anonymous key for each $ (\msg, \pk_\simulator) $)
				\item Else set $ b = b_\sim$. \label{cond:simulatorbit}
			\end{enumerate}		
			
		\end{list}
		In the end,  record $ [\msg,\aux,W,\ring,\sigma, 0] $ if it is not stored. If $ b = 0 $, let $y = \perp $. Otherwise,   do the following:
		\begin{itemize}
			\item if $ W \notin \anonymouskeylist[\msg,\ring] $, add $ W $ to $ \anonymouskeylist[\msg,\ring]  $.
			%\item if $ \pk_\simulator $ is not recorded, record it in $ \vklist $ under $ \simulator $.
			\item if $ \evaluationslist[\msg,W] $ is not defined, set $ \evaluationslist[\msg, W]\leftsample \setsym{S}_{eval}$, $ \anonymouskeymap[\msg,W]  = \pk_\simulator$.  Set $ \evaluationslist[\msg, W] = y$.
			\item otherwise, set $ y = \evaluationslist[\msg, W]$. 	
		\end{itemize}
		Finally, output $(\oramsg{verified}, \sid, \ring,W, \aux,\msg, \sigma, y, b)$ to the party.
		
	\end{tcolorbox}
	
	In real-world ring VRF, the verification algorithm outputs the corresponding evaluation value of the signer. Therefore, $ \fgvrf $  outputs the signer's evaluation value if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key for  each signature, then there would be no way that $ \fgvrf $ determines the signer's key and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key for the sake of anonymity. Therefore, $ \fgvrf $ maps a random and independent anonymous key to each $ \msg $ and $ \pk $ so that this key behaves as if it is the verification key of the signature. Since it  is  random and independent from $ \msg $ and $ \pk $, it does not leak any information about the signer during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	
	
	%In $\fgvrf$, we suppress
	%associated data and ring commitment details to make our UC functionality
	%more accessible, meaning our ring commitment is simply the full ring. We introduce more variations of ring VRF functionalities in Appendix \ref{sec:morefuncs} with additional security properties.
	%Here are several important remarks that help elucidate $\fgvrf$ in Figure \ref{f:gvrf}:
	
	
	%
	%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	%	\item Each party is distinguished by a unique verification key which is given by the simulator. Verification keys have the identifier role of  the signatures and outputs rather than  influencing the value of them. Therefore, there exists no secret key as in the real world protocol. \eprint{We note that we need to define verification keys in $ \fgvrf $ because the real world protocol $ \rVRF $ defines a verification key (or public key) for each party.}{}
	%	
	%	\item In ring VRF, the verification algorithm outputs the corresponding evaluation value of the verified signature. Therefore, $ \fgvrf $  outputs the corresponding output during the signature verification if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key of each signature, then there would be no way that $ \fgvrf $ determines the actual verification key of the signature $ \sigma $ and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key. Therefore, $ \fgvrf $ maps a random anonymous key to each $ \msg $ and $ \pk $ so that this key behaves as if it is the verification key of the signature. Since it  is  random and independent from $ \msg $ and $ \pk $, it does not leak any information about the signer during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	%	
	%	\item $ \fgvrf $ does not have a separate signing protocol for malicious parties as honest parties because they can generate it as they want. If they generate a signature, it is added to the $ \fgvrf $'s records as valid or invalid when an honest party sends a verification message of it.  Its validity depends on $ \simulator $ as it can be seen in  the condition C\ref{cond:malicioussignature} in Figure \ref{f:gvrf}. 
	%	
	%	\item Once $ \simulator $ obtains an anonymous key $ W $ of a message $ \msg $ generated for an honest party with a key $ \pk $, we let $ \simulator $ learn the  evaluation of  $ \msg $ with $ \pk $ without knowing the $ \pk $. $ \simulator $ can do this via malicious ring VRF evaluation i.e., send the message $ (\oramsg{eval}, \sid, \pk_i,W,\msg) $ where $ \pk_i $ is a malicious verification key. Here, if $ W $ is an anonymous key of $ \msg, \pk  $, $ \fgvrf $ returns $ \evaluationslist[\msg, W] $ even if $ \pk \neq \pk_i $. 
	%	%$ \fgvrf $ returns it independent from which verification key given in $ \simulator $'s message. 
	%	
	%	\item Once $ \simulator $ obtains an anonymous key of a message $ \msg $ generated for an honest party, it can learn all valid signatures generated by $ W $ for a ring $ \ring $ and $ \msg $ via malicious requests of signatures.
	%	
	%	\item Each honest party's public key $ \pk $ is associated with a unique key $ x $ which is only used to generate honest signatures by $ \Gen_{sign} $. It is never shared with honest parties. It corresponds to the secret key of $ \pk $ in the real protocol in our instantiation of $ \Gen_{sign} $ (Algorithm \ref{alg:gensign}). Since an honest signature can be only generated by honest parties (showed below), even if $ x $ is a secret key, it does not help $ \simulator $ to generate forgeries in the ideal world.
	%	
	%\end{enumerate}
	% The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (Ring VRF Evaluation), sign a message by one of the keys (Ring VRF signature) and verify the signature and obtain the evaluation output without knowing the key used for the signature and evaluation (Ring VRF Verification). 
	%
	%%We also define linking procedures in $ \fgvrf $ to link a signature with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to show that the evaluation is executed with its key (Linking Signature). Later on, anyone can verify the linking signature (Linking Verification).
	%
	%In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\ring$ (that we call a ring) of party, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\ring$ without revealing who they are. At a later stage, the author of the ring VRF output can prove that the output was generated by him and no other participant could have done so.
	$ \fgvrf $  achieves the following security properties. We note that when we say the evaluation value of $ (\msg, \pk_i) $, we mean $ \evaluationslist[\msg,W] $ where $ \anonymouskeymap[\msg,W] = \pk_i $.
	
	\paragraph{Randomness:}  The evaluation value of $ (\msg, \pk_i) $ is randomly selected independent from $ (\msg, \pk_i) $ for keys $ \pk_i $ and $ \msg $'s. The evaluation value of pairs in $ \{(\msg, \pk_i)\} $  with an anonymous key $ W $ provided by $ \simulator $  is randomly selected independent from $ \{(\msg, \pk_i)\} $ for all malicious keys $ \pk_i  $ and $ \msg $'s.
	
	%Given that the evaluation of $  m, \pk  $ for any verification key $ \pk $ and for any message $ m $ has never been given to $ \simulator $, the probability that $ \simulator $ guesses the evaluation of $ m, \pk_i $ is $ \frac{1}{2^{\ell_\rvrf}} $, given that $  $
	
	Evaluation of $ (\msg, \pk_i) $ where $ \pk_i $ is an honest key is generated by first assigning a random anonymous key $ W $ to it and then assigning a random evaluation value $ y $ to $ (\msg, W)$. So, honest evaluations are always random and independent from $ (\msg,\pk_i) $. Malicious evaluation value of pairs $ \{(\msg, \pk_i)\} $ with the same anonymous $ W $ is $ \evaluationslist[\msg,W] $ which is sampled randomly and independently from $ \{(\msg,\pk_j)\} $ by $ \fgvrf $.
	
	
	
	
	\paragraph{Determinism:} The evaluation value  of $ (\msg, \pk_i) $, once it has been evaluated, is unique and  cannot be changed. 
	
	%$ \fgvrf $ satisfies determinism because it checks whether $ (\msg, \pk_i) $ is evaluated before every time that it needs it. The evaluation of $ (\msg, \pk_i) $ could be changed by changing the anonymous key of $ (\msg, \pk_i)  $ but the anonymous keys cannot be changed similarly once it is set. 
	The evaluation value of $ (\msg, \pk_i) $ where $ \pk_i $ is honest is unique and cannot be changed for honest parties because the anonymous key of it selected only once. Similarly, The evaluation value of $ (\msg, \pk_i) $ where $ \pk_i $ is malicious is unique and cannot be changed because $ \fgvrf $ does not allow $ \simulator $ to select two different anonymous keys for  $ (\msg, \pk_i) $ and to update the anonymous key.
	
	\paragraph{Unforgeability:}  If an honest party with a public key $ \pk $ never signs a message $ \msg $  and an associated data $ \aux $ for a ring $ \ring $, then no party can generate a  forgery of $ \msg $ and $ \aux $ for $ \ring $ signed by $ \pk $. Formally, if an honest party with $ \pk $ never sends a message $(\oramsg{sign}, \sid, \ring, \pk,\aux, \msg)$ for any $ \ring, \msg, \aux $, then  no party can create a record in $ \fgvrf $ such that $ [\msg, \aux,W,\ring, \sigma, 1] $ where $ \anonymouskeymap[\msg,\pk] = W $.
	
	%We need verify that $ \sim $ cannot generate a signature $ \sigma $ that signs a message $ m $ for a ring $ \ring $ by an honest party's key $ \pk $. In other words, we need to verify that if $ \fgvrf $ never received a message $ (\oramsg{sign}, \sid,\ring,\pk,m) $ from an honest party $ \user $ with the key $ \pk $, $ \fgvrf $ cannot have a record $ [m, W, \ring, \sigma, 1] $ such that $ \anonymouskeymap[m,W]  = \pk$ (meaning that $ \sigma $ is a valid signature generated by the honest key $ \pk $). 
	$ \sim $ cannot create a forgery by sending a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg) $ to $ \fgvrf $ because $ \fgvrf $ checks whether the sender's key is $ \pk $ to generate a signature. Another way for $ \sim $ to create a forgery is by sending an honest key $ \pk_\simulator $  in C\ref{cond:malicioussignature}. However, this is also not allowed by $ \fgvrf $ in condition C3-\ref{cond:forgery}.\eprint{ So, the only way that $ \fgvrf $ has a record $ [\msg, \aux,W,\ring, \sigma, 1] $ where $ \anonymouskeymap[\msg,\pk] = W $ is receiving a message $ (\oramsg{sign}, \sid,\ring,\pk,\aux,\msg)  $ from the honest party $\user  $ with key $ \pk $. Therefore, forgery is not possible in $ \fgvrf $.}{}
	
	\paragraph{Uniqueness:} We call that an evaluation value $ y $ for a message $ \msg $  is verified for $ \ring $, if there exists a signature $ \sigma $ such that $ \fgvrf$ returns $ (y, 1)$ for a query $ (\oramsg{verify}, \sid, \ring,W,\aux,\msg,\sigma)$ for any anonymous key $ W $ and associated data $\aux $. The uniqueness property guarantees that the number of verified evaluation values via signatures for a message $ \msg $ and $ \ring $ is not more than $ |\ring| $.
	
	If $ \fgvrf $ outputs $ (1,y) $, it means that there exists a record $ [\msg, ., W,\ring, \sigma,1] $ and $ y = \evaluationslist[\msg, W] $, $ \anonymouskeymap[\msg, W]  = \pk$.  If $ \pk $ is an honest key, then it means that $ \pk \in \sigma $ because $ \fgvrf $ generates a signature for an honest party with a key if $ \pk \in \ring $. Let's assume that there exist more verified evaluation values for $ \ring $
	
	
	The evaluation value of $ \msg, \pk_i $ is unique and fixed thanks to the determinism. 
	Uniqueness is broken if the number of verified evaluation values of $ \msg $ for $ \ring $ is greater than the number of anonymous keys that verify a signature that signs $ \msg $ for $ \ring $.
	Assume that there exist $ t$ different verified evaluation values $ \setsym{Y} = \{y_1, y_2, \ldots, y_t\} $ of a message $ \msg $ for $ \ring $ where $ |\ring| = t-1 $. This implies that for each $ y_i \in \setsym{Y} $, there exists a  record $ [\msg, \aux_i, W_i,\ring,\sigma_i,1] $ such that  $\evaluationslist[\msg,W_i] = y_i $ where $ \anonymouskeymap[\msg,W_i] = \pk_i $ and $ W_i \neq W_j $ for all $ i,j \in [1,t] $. We know from the determinism property $ \pk_i \neq \pk_j $ for all $ i \neq j \in [1,t] $. 
	If $ \pk_i $ is an honest key, it means that $ \sigma_i $ is not a forgery so $ \pk_i \in \ring $. Therefore, each honest evaluation value  in $ \setsym{Y} $ maps to one honest public key in $ \ring $ meaning that honest evaluation values in $ \setsym{Y} $ is at most $ |\ring \setminus \ring_{mal}| = n_h $. If $ \pk_i $ is not an honest verification key, $ W_i \in \anonymouskeylist[\msg,\ring] $ since $ \fgvrf $ adds $ W_i $ to $ \anonymouskeylist[\msg, \ring] $ whenever it creates such record for a malicious signature. $ \fgvrf $ makes sure that in the condition C3-\ref{cond:uniqueness} that $ \anonymouskeylist[\msg,\ring] \leq |\ring_{mal}| = n_m$. Therefore, $ t \leq n_h + n_m = |\ring| $ which is a contradiction.
	
	We note that $ \simulator $ in our functionality can generate a valid ring signature $ \sigma $ that signs $ \msg $ with a malicious key $ \pk $ for $ \ring $ where the malicious key is not in $ \ring $ i.e.,  $ \fgvrf $  can have a record for a malicious signature $ \sigma $ such that $ [\msg, ., W_i,\ring,\sigma,1] $ and $ \anonymouskeymap[\msg,W]  = \pk \notin \ring$. However, it cannot create signatures of $ \msg $ for $ \ring $ which $ \fgvrf $ verifies and outputs more than  $ |\ring_{mal}| $  different evaluation values.  
	
	
	
	%
	% Clearly, in this case, $ W_i \neq W_j $ for all $ i \neq j $ since $ y_i \neq y_j $ by our assumption. The number of verified honest signatures in $ \setsym{S} $ cannot be more than number of honest verification keys in $ \ring $ because $ \fgvrf $ generates a signature for an honest party if the honest key is in the ring. Since each $ \msg,\pk $ is mapped to one unique evaluation value,
	%
	%Also, it generates a unique anonymous key for each pair $ \msg,\pk $. So, if an honest signature for $ \msg,\ring $ is verified it means that the honest verification key $ \pk $ is in $ \ring $ and $ (\msg,\pk) $ has a unique anonymous key so that unique evaluation output. Therefore, the number of anonymous keys (so that evaluation outputs) for the honest signatures is at most number of honest keys in $ \ring $. Since we know that once anonymous key $ W_i $ is set for $ m, \pk_i $, it cannot be changed. This means that there exist at least $ |\ring_{mal}| + 1 $ signatures in $ \setsym{S} $. When $ \fgvrf $ verifies a malicious signature, it checks in the condition C3-\ref{cond:uniqueness} how many malicious anonymous keys generated for malicious signatures of $ m, \ring $ so far. If it is more that $ |\ring_{mal}| $, $ \fgvrf $ does not verify it so that it does not output an evaluation value during such signature verification. Therefore, the simulator can generate at most $ |\ring_{mal}| $ anonymous keys for verified signatures for $ \ring $. This implies that the number of verified outputs of malicious parties   is $ |\ring_{mal}| $. 
	
	\eprint{\paragraph{Robustness:} $ \simulator $ cannot prevent an honest party to evaluate, sign or verify.
		The only place that $ \fgvrf $ does not respond any query is when it aborts. It happens when it selects an honest anonymous key which already existed. This happens in negligible probability in $ \secparam $. }{}
	
	
	\paragraph{Anonymity:} An honest signature $ \sigma $ signs a message $ \msg $ verified by a ring and anonymous key $ W $ does not give any information about its signer except that its key is in $ \pk $ if $ \msg $ is not signed by the same signer before for any other ring. We define this formally with the anonymity game below. We note that we cannot define and verify this property in $ \fgvrf $ like we did for the other properties because it depends on how $ \Gen_{sign} $ is defined.
	
	\begin{definition}[Anonymity]\label{def:anonymity} We define the anonymity game against a special environment $ \mathcal{D} $ which plays the following anonymity game.
		$ \fgvrf $ satisfies anonymity, if any PPT distinguisher $ \mathcal{D} $ has a negligible advantage in $ \secparam $ to win the anonymity game defined as follows:
		We define the anonymity game between a challenger and $ \mathcal{D} $.  $\mathcal{D}$ accesses a signing oracle $ \mathcal{O}_{Sign} $ and $ \fgvrf $ simulated by the challenger as described in Figure \ref{f:gvrf}. 
		\begin{itemize}
			\item Given the input $ '\mathsf{keygen}' $, $\mathcal{O}_{Sign} $ sends $ (\oramsg{keygen, \sid}) $ to the challenger and obtains a verification key $ \pk $. Then, it stores $ \pk $ to a list $ \mathcal{K} $ and outputs $ \pk $.
			\item Given the input $ '(\pk,\ring,\aux,\msg)' $, $ \mathcal{O}_{Sign} $ sends $ (\oramsg{sign}, \sid,\ring,\pk, \aux, \msg) $ to the challenger and receives $ (\oramsg{signature}, \sid, \ring, W,\aux, \msg, y, \sigma) $ if $ \pk \in \ring $.  Then $ \mathcal{O}_{Sign} $ stores $ \msg $ to a list $ \arraysym{signed}[\pk]  $.
			% and $ W  $ to a list $ \anonymouskeylist $. 
			It outputs $ (\sigma,W) $. Otherwise, it outputs $ \perp $.
		\end{itemize}
		At some point,	
		$ \mathcal{D} $ sends $ (\ring, \pk_0, \pk_1, \msg,\aux)$ to  the challenger where $ \pk_0, \pk_1 \in \ring $, $ \msg  \notin \arraysym{signed}[\pk_0]$ and $ \msg  \notin \arraysym{signed}[\pk_1] $.  Challenger lets $ b \leftarrow_r\bin$. Then it gives the input $ (\pk_b, \ring, \msg,\aux) $ to $ \ora{Sign} $ and receives either $ \perp $ or $(\sigma,W)$. If it is $ (\sigma,W) $, it sends $ (\sigma,W) $ to $ \mathcal{D} $ as a challenge.
		If $ \mathcal{D} $ sends $ '(\pk,\ring,\aux,\msg)' $ to $ \mathcal{O}_{Sign} $ where $ \pk = \pk_0 $ or $ \pk = \pk_1 $, it loses the game. 
		During the game if $ \mathcal{D} $ outputs $ b' = b $, $ \mathcal{D} $ wins.
		
		
	\end{definition}
	
	
	
	We remark that $ \mathcal{D} $ generates keys of honest parties and forwards them via dummy adversaries in the ideal model. So, $ \Gen_{sign} $ of $ \fgvrf $ should be defined in a way that it preserves the anonymity even if $ \mathcal{D} $ generates the keys.
	
	
	%
	%to make $ \fgvrf $ set $ \anonymouskeymap[m,W] $ with an honest key for any $ m,W $.  Let's see whether this is possible. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature.
	
	%
	% to generate a valid signature is via verification i.e., when a party sends a message  $ (\oramsg{verify}, \sid,\ring,W,m, \sigma) $ to $ \fgvrf $.  During the verification, if $ \fgvrf $ is in \ref{cond:differentsignature} and \ref{cond:simulatorbit} then the validity of the signature is decided by $ \simulator $. If $ \fgvrf $ is in \ref{cond:simulatorbit}, it means that there exists no $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H $ because if it existed, $ \fgvrf $ would be in \ref{cond:differentsignature}. Therefore, the signature verified in \ref{cond:simulatorbit} cannot be a signature of an honest party's key.  This means that $ \simulator $ cannot generate a forgery via \ref{cond:simulatorbit}. So, the only left way for $ \simulator $ to generate a forgery is via \ref{cond:differentsignature}.
	%If $ \fgvrf $ is in \ref{cond:differentsignature}, then $ \anonymouskeymap[m,W] $ belongs to an honest party and another signature $ \sigma' \neq \sigma $ has already been stored as valid for $ W, \ring, m $.  If $ \sigma' $ is not generated by this honest party, then it means that $ \simulator $ forges. Let's see whether this is possible. If there exists a record $ [m, W, \ring, \sigma',1] $ , it means that $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H$ exists. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature via \ref{cond:differentsignature}.
	
	
	
	%Now, we verify that $ \fgvrf $ satisfies these properties. During our analysis, when we say that a message $ m $ signed by an anonymous key $ W $ we mean that $ [m,W,.,.,1] $ is recorded. We say that the signature is honest if $ \anonymouskeymap[m,W] = \pk $ is an honest party's key.
	%
	%
	%
	%\paragraph{\textbf{Uniqueness:}}
	%
	%\paragraph{\textbf{Robustness:}} We check whether $ \simulator$ can prevent an honest party signing and verifying. $ \fgvrf $ does not abort during the verification so an honest party can verify all signatures. $ \fgvrf $ aborts during the honest signing process if $ \gen_{sign}(m, \ring) $ generates a signature which was invalidated before i.e., there exists a record $ [m, W, \ring, \sigma,0] $.
	%
	%
	%
	%
	%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	%
	%%\item The ring VRF signature does not need to be random but it must be \emph{unique}  for its ring and the message. The reason of it to have a mapping from a ring VRF signature to its evaluation output. The map is necessary for $ \fgvrf $ to output the corresponding evaluation value for the signature during the verification process i.e, $ [m, \ring, \sigma] \rightarrow \pk, \evaluationsecretlist[m, \ring][\pk] \rightarrow y $.
	%\item In classical VRF, a VRF $ F $ is a deterministic function which maps a message and a public key to a random output. While in ring VRF, a message, a public key and a ring map to a random value, the verification algorithm of a ring VRF does not take the key as an input because it should be hidden. Therefore, the verification should be executed without the public key.  So, the functionality $ \fgvrf $ needs to find a way to verify the ring VRF output of a message, a public key and a ring map without knowing the public key. Because of this, $ \fgvrf $ generates an anonymized key $ W $ for each evaluation so that a message $ m $  and $ W $ maps to the random output. One can imagine this  as if a VRF output is generated with the input message $ m $ and the key $ W $ as in classical VRF i.e.,  $ F(m, W) $. 
	%
	%\item  If an honest party signs a message for a ring and obtains a signature, $ \fgvrf $ allows the simulator to generate another signature in \ref{cond:differentsignature} if the simulator wants. We remark that this is not a security issue because an honest party has already committed to sign the message.  A similar condition  exists in the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
	%
	%\item \ref{cond:simulatorbit} of the ring VRF verification process covers the case where the adversary decides whether accepting the signature generated for its key if  it could be a valid signature for the ring i.e., the malicious key is in the ring and the anonymous key in the verification request is unique.
	%
	%\item The linking signature and the linking verification works similar to the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
	
	
	%\end{enumerate}
	
	
	%\begin{definition}[Anonymous $ \fgvrf $]\label{def:anonymity}
	%	We call that $ \fgvrf $ is anonymous if the outputs of $ \gen_{sign} $ and $ \gen_W $ are pseudo-random.
	%	%TODO define this more formally.
	%\end{definition}
	
	
	%
	%Below, we define the real-world execution of a ring VRF.
	%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
	%	%TODO ADD anonymous key here
	%	A ring VRF is a VRF with a  function $ F(.):\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
	%	
	%	\begin{itemize}
		%		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pk)$ where $ \kappa $ is the security parameter,
		%	\end{itemize}
	%	Given list of public keys $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$, a message $ m \in \{0,1\}^{\ell_m} $
	%	\begin{itemize}
		%		\item $ \rvrf.\eval(\skrvrf_i, \ring, m) \rightarrow y$
		%		\item $ \rvrf.\sign(\skrvrf_i, \ring, m)\rightarrow (\sigma,W) $ where  $\sigma $ is a signature of the message $ m $ signed by $ \skrvrf_i, \ring $ and $ W $ is an anonymous key.
		%		\item $ \rvrf.\verify(\ring,W, m,\sigma) \rightarrow  (b, y)$ where $ b \in \{0,1\} $ and $ y \in \{0,1\}^{\ell_\rvrf}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
		%%		\item $ \rvrf.\link(\skrvrf_i, \ring,W,m, \sigma) \rightarrow \hat\sigma $ where  $ \hat\sigma $ is a signature that links signer of the ring signature $ \sigma $. 
		%%		\item $ \rvrf.\link\verify( \pk_i,\ring,W, m, \sigma, \hat\sigma)\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
		%	\end{itemize}
	%	
	%\end{definition}
