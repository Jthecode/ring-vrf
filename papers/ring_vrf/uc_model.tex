
\subsection{UC model}
\label{subsec:uc_model}

In this section, we define the security of  a ring VRF protocol in the UC model. We introduce a ring VRF functionality $ \fgvrf $ satisfying the security properties we want to achieve in $ \rVRF $. These properties are informally as follows: \emph{randomness} meaning that an evaluation value is random and independent from the message, ring and the public key, \emph{determinism} meaning that $ \rVRF.\Eval $ outputs always the same evaluation value, \emph{anonymity} meaning that $ \rVRF.\Sign $ does not give information about its signer, \emph{unforgeability} meaning that an adversary should not generate a forged signature and \emph{uniqueness} meaning that number of verified evaluation values should not be more than the number of the keys in the public key.

In Figure \ref{f:gvrf}, we give a UC functionality $\fgvrf$ for ring VRFs.  In $\fgvrf$, we suppress
auxiliary data and ring commitment details to make our UC functionality
more accessible, meaning our ring commitment is simply the full ring both
here. We introduce more variations of ring VRF functionalities in Appendix \ref{sec:morefuncs} with additional security properties.

We give several important remarks that help elucidate $\fgvrf$ in Figure \ref{f:gvrf}:



\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
	\item Each party is distinguished by unique verification key which is given by the simulator. Verification keys have the identifier role of  the signatures and outputs rather than  influencing the value of them. Therefore, there exists no secret key as in the real world protocol.
	
	\item In ring VRF, the verification algorithm outputs the corresponding evaluation value of the verified signature. Therefore, $ \fgvrf $  outputs the corresponding output during the signature verification if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key of each signature, then there would be no way that $ \fgvrf $ determines the actual verification key of the signature $ \sigma $ and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key or unique. Therefore, $ \fgvrf $ associates an anonymous key for each $ m $ and $ \pk $ so that this key behaves as if it is the verification key of the signature during the verification. Since each anonymous key of an honest party selected randomly and independent from $ m $ and $ \pk $, it does not leak any information about the signer during the verification but it still allows $ \fgvrf $ to distinguish the signer.
	
	\item $ \fgvrf $ does not have a separate signing protocol for malicious parties as honest parties because they can generate it as they want. If they generate a signature, it is added to the $ \fgvrf $'s records as valid or invalid when a party comes for the verification of it.  Its validity depends on $ \simulator $ as it can be seen in C-\ref{cond:malicioussignature}. 
	
	\item Once $ \simulator $ obtains an anonymous key of a message $ m $ generated for an honest party, we let $ \simulator $ learn the  evaluation of  $ m $ and  $ W $. $ \simulator $ can do this via malicious ring VRF evaluation i.e., send the message $ (\oramsg{eval}, \sid, \pk_i,W,m) $. Here, if $ W $ is an anonymous key of $ m, \pk  $, $ \fgvrf $ returns $ \evaluationslist[m, W] $ even if $ \pk \neq \pk_i $. $ \fgvrf $ returns it independent from which verification key given in $ \simulator $'s message. 
	
	\item Once $ \simulator $ obtains an anonymous key of a message $ m $ generated for an honest party, it can learn all valid signatures generated by $ W $ for a ring $ \ring $ and $ m $ via malicious requests of signatures.
	
\end{enumerate}
% The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (Ring VRF Evaluation), sign a message by one of the keys (Ring VRF signature) and verify the signature and obtain the evaluation output without knowing the key used for the signature and evaluation (Ring VRF Verification). 
%
%%We also define linking procedures in $ \fgvrf $ to link a signature with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to show that the evaluation is executed with its key (Linking Signature). Later on, anyone can verify the linking signature (Linking Verification).
%
%In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\ring$ (that we call a ring) of party, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\ring$ without revealing who they are. At a later stage, the author of the ring VRF output can prove that the output was generated by him and no other participant could have done so.
We construct $ \fgvrf $ so that it achieves the following properties:

\paragraph{Randomness:}  The evaluation of $ (m, \pk_i) $,  which is $ \evaluationslist[m,W] $ where $ \anonymouskeymap[m,W] = \pk_i $, is randomly selected independent from $ (m, \pk_i) $.

%Given that the evaluation of $  m, \pk  $ for any verification key $ \pk $ and for any message $ m $ has never been given to $ \simulator $, the probability that $ \simulator $ guesses the evaluation of $ m, \pk_i $ is $ \frac{1}{2^{\ell_\rvrf}} $, given that $  $

Each element in $ \evaluationslist $ are selected randomly by $ \fgvrf $. Therefore, $ \fgvrf $ satisfies randomness.  Evaluation of $ (m, \pk_i) $ where $ \pk_i $ is an honest key is generated by first assigning a random anonymous key $ W $ to it and then assigning a random evaluation value $ y $ to $ m, W $. Therefore, honest evaluations are always random and independent from $ (m,\pk_i) $. Malicious evaluation of $ (m, \pk_i) $, where $ \pk_i $ is not an honest verification key, is generated by first assigning an anonymous key $ W $ given by $ \simulator $ to it and then assigning a random value $ y $ to $ m, W $. Since $ \fgvrf $ checks whether $ W $ is an anonymous key of another verification key, evaluation of $ (m, \pk_i) $ is always random. If $ \fgvrf $ did not check this, then the evaluation of $ m, \pk_i $ would be the same as the evaluation of $ m, \pk_j  \neq \pk_i$ whose anonymous key is $ W $.





\paragraph{Determinism:} Once evaluation of $ (m, \pk_i) $, which is $ \evaluationslist[m,W] $ where $ \anonymouskeymap[m,W] = \pk_i $, is set, it cannot be changed. 

$ \fgvrf $ satisfies determinism because it checks whether $ (m, \pk_i) $ is evaluated before any time that it needs it. The only way for $ \simulator $ to change the evaluation of $ (m, \pk_i) $ is by changing the anonymous key of $ (m, \pk_i)  $ but the anonymous key cannot change once it is set i.e., $ \fgvrf $ always checks whether there exists $ W $ where $ \anonymouskeymap[m,W]  = \pk_i$ whenever it needs the evaluation value.

\paragraph{Anonymity:} An honest signature $ \sigma $ of a message $ m $ verified by a ring $ \ring $ does not give any information about its signer except that its key is in $ \pk $. We define it more formally.

\begin{definition}[Anonymity]\label{def:anonymity}
	$ \fgvrf $ satisfies anonymity, if any PPT distinguisher $ \mathcal{D} $ has a negligible advantage in $ \secparam $ to win the anonymity game defined as follows:
	
	We define the anonymity game between the environment $ \env $ and a distinguisher $ \mathcal{D} $ in the real world.  $\mathcal{D}$ accesses a signing oracle $ \mathcal{O}_{Sign} $ run by $ \env $ that we define below. 
	\begin{itemize}
		\item Given the input $ '\mathsf{keygen}' $, $\mathcal{O}_{Sign} $ creates an honest party in the ideal protocol and obtains its verification key $ \pk $, stores $ \pk  $ to a list $ \mathcal{K} $ and outputs $ \pk $.
		\item Given the input $ '(\pk,\ring,\msg)' $, $ \mathcal{O}_{Sign} $ commands the honest party with $ \pk$ to sign $ m $ and output the signature $ \sigma $ and the anonymous key $ W $ if $ \pk \in \ring $ and $\pk \in \mathcal{K}  $.  Then $ \mathcal{O}_{Sign} $ stores $ \msg $ to a list $ \arraysym{signed}[\pk]  $ and $ W  $ to a list $ \anonymouskeylist $. It outputs $ (\sigma,W) $. Otherwise, it outputs $ \perp $.
	\end{itemize}
	At some point of the game,	
	$ \mathcal{D} $ sends $ (\ring, \pk_0, \pk_1, \msg )$ to $ \env $ where $ \pk_0, \pk_1 \in \ring $, $ \msg  \notin \arraysym{signed}[\pk_0]$ and $ \msg  \notin \arraysym{signed}[\pk_1] $.  Challenger picks a bit $ b $ randomly. Then it gives the input $ (\pk_b, \ring, \msg) $ to $ \ora{Sign} $ and receives either $ \perp $ or $(\sigma,W)$. If it is $ (\sigma,W) $, it sends $ (\sigma,W) $ to $ \mathcal{D} $ as a challenge.
	Otherwise, $ \env $ outputs $ \perp $ and $ \adv $ loses the game.
	During the game if $ \mathcal{D} $ outputs $ b' = b $, $ \mathcal{D} $ wins the game.
	
	
\end{definition}


\paragraph{Unforgeability:}  If an honest party with a public key $ \pk $ never signs a message $ m $ for a ring $ \ring $, then no party is able to generate a valid signature of $ m $ for $ \ring $ signed by $ \pk $. 

We need verify that $ \sim $ cannot generate a signature $ \sigma $ that signs a message $ m $ for a ring $ \ring $ by an honest party's key $ \pk $. In other words, we need to verify that if $ \fgvrf $ never received a message $ (\oramsg{sign}, \sid,\ring,\pk,m) $ from an honest party $ \user $ with the key $ \pk $, $ \fgvrf $ cannot have a record $ [m, W, \ring, \sigma, 1] $ such that $ \anonymouskeymap[m,W]  = \pk$ (meaning that $ \sigma $ is a valid signature generated by the honest key $ \pk $). 
$ \sim $ cannot execute the forgery attack by sending a message $ (\oramsg{sign}, \sid,\ring,\pk,m) $ to $ \fgvrf $ because $ \fgvrf $ checks whether the sender of this message is associated with the key $ \pk $ to generate a signature. Another way for $ \sim $ to create a forgery is by sending an honest key $ \pk_\simulator $  in C-\ref{cond:malicioussignature} in Figure \ref{f:gvrf}. However, it is not allowed by $ \fgvrf $ in \ref{cond:forgery} neither.


%
%to make $ \fgvrf $ set $ \anonymouskeymap[m,W] $ with an honest key for any $ m,W $.  Let's see whether this is possible. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature.

%
% to generate a valid signature is via verification i.e., when a party sends a message  $ (\oramsg{verify}, \sid,\ring,W,m, \sigma) $ to $ \fgvrf $.  During the verification, if $ \fgvrf $ is in \ref{cond:differentsignature} and \ref{cond:simulatorbit} then the validity of the signature is decided by $ \simulator $. If $ \fgvrf $ is in \ref{cond:simulatorbit}, it means that there exists no $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H $ because if it existed, $ \fgvrf $ would be in \ref{cond:differentsignature}. Therefore, the signature verified in \ref{cond:simulatorbit} cannot be a signature of an honest party's key.  This means that $ \simulator $ cannot generate a forgery via \ref{cond:simulatorbit}. So, the only left way for $ \simulator $ to generate a forgery is via \ref{cond:differentsignature}.
%If $ \fgvrf $ is in \ref{cond:differentsignature}, then $ \anonymouskeymap[m,W] $ belongs to an honest party and another signature $ \sigma' \neq \sigma $ has already been stored as valid for $ W, \ring, m $.  If $ \sigma' $ is not generated by this honest party, then it means that $ \simulator $ forges. Let's see whether this is possible. If there exists a record $ [m, W, \ring, \sigma',1] $ , it means that $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H$ exists. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature via \ref{cond:differentsignature}.

\paragraph{Uniqueness:} The number of verified outputs via signatures for a message and a ring $ \ring $ is not more than $ |\ring| $.

We need to verify that number of outputs for a message $ m $ that are verified by the ring $ \ring $ is not greater than $ |\ring| $.
Assume that there exist $ t + 1 $ verified signatures $ \setsym{S} = \{\sigma_1, \sigma_2, \ldots, \sigma_t\} $ of a message $ m $ for a ring $ \ring $ where $ |\ring| = t $ and $ \fgvrf $ outputs $ 1, y_i $ for each query $ (\oramsg{verify}, \sid, \ring, W_i, m, \sigma_i) $ where $ y_i \neq y_j $ for all $ i \neq j $. For each $ \sigma_i \in \setsym{S} $, $ \anonymouskeymap[m,W_i] = \pk_i $ and $\evaluationslist[m,W_i] = y_i $. Clearly, in this case, $ W_i \neq W_j $ for all $ i \neq j $ since $ y_i \neq y_j $ by our assumption. $ \fgvrf $ generates a signature for an honest party if the honest key is in the ring. Therefore, the number of anonymous keys (so that evaluation outputs) for the honest signatures is at most number of honest keys in $ \ring $. Since we know that once anonymous key $ W_i $ is set for $ m, \pk_i $, it cannot be changed. This means that there exist at least $ |\ring_{mal}| + 1 $ signatures in $ \setsym{S} $. When $ \fgvrf $ verifies a malicious signature, it checks in \ref{cond:uniqueness} whether the number of malicious anonymous keys for $ m $ are greater than the number of malicious keys in the corresponding ring. Therefore, the simulator can generate at most $ |\ring_{mal}| $ anonymous keys generate for a ring $ \ring $. This implies that the number of verified outputs of malicious parties   is $ |\ring|_{mal} $. 

\paragraph{Robustness:} $ \simulator $ cannot prevent an honest party to evaluate, sign or verify.

The only place that $ \fgvrf $ does not respond any query is when it aborts. This happens only when it selects an honest anonymous key which already existed. Since this happens in negligible probability,  $ \fgvrf $ is robust.

%Now, we verify that $ \fgvrf $ satisfies these properties. During our analysis, when we say that a message $ m $ signed by an anonymous key $ W $ we mean that $ [m,W,.,.,1] $ is recorded. We say that the signature is honest if $ \anonymouskeymap[m,W] = \pk $ is an honest party's key.
%
%
%
%\paragraph{\textbf{Uniqueness:}}
%
%\paragraph{\textbf{Robustness:}} We check whether $ \simulator$ can prevent an honest party signing and verifying. $ \fgvrf $ does not abort during the verification so an honest party can verify all signatures. $ \fgvrf $ aborts during the honest signing process if $ \gen_{sign}(m, \ring) $ generates a signature which was invalidated before i.e., there exists a record $ [m, W, \ring, \sigma,0] $.
%
%
%
%
%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
%
%%\item The ring VRF signature does not need to be random but it must be \emph{unique}  for its ring and the message. The reason of it to have a mapping from a ring VRF signature to its evaluation output. The map is necessary for $ \fgvrf $ to output the corresponding evaluation value for the signature during the verification process i.e, $ [m, \ring, \sigma] \rightarrow \pk, \evaluationsecretlist[m, \ring][\pk] \rightarrow y $.
%\item In classical VRF, a VRF $ F $ is a deterministic function which maps a message and a public key to a random output. While in ring VRF, a message, a public key and a ring map to a random value, the verification algorithm of a ring VRF does not take the key as an input because it should be hidden. Therefore, the verification should be executed without the public key.  So, the functionality $ \fgvrf $ needs to find a way to verify the ring VRF output of a message, a public key and a ring map without knowing the public key. Because of this, $ \fgvrf $ generates an anonymized key $ W $ for each evaluation so that a message $ m $  and $ W $ maps to the random output. One can imagine this  as if a VRF output is generated with the input message $ m $ and the key $ W $ as in classical VRF i.e.,  $ F(m, W) $. 
%
%\item  If an honest party signs a message for a ring and obtains a signature, $ \fgvrf $ allows the simulator to generate another signature in \ref{cond:differentsignature} if the simulator wants. We remark that this is not a security issue because an honest party has already committed to sign the message.  A similar condition  exists in the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
%
%\item \ref{cond:simulatorbit} of the ring VRF verification process covers the case where the adversary decides whether accepting the signature generated for its key if  it could be a valid signature for the ring i.e., the malicious key is in the ring and the anonymous key in the verification request is unique.
%
%\item The linking signature and the linking verification works similar to the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.


%\end{enumerate}


%\begin{definition}[Anonymous $ \fgvrf $]\label{def:anonymity}
%	We call that $ \fgvrf $ is anonymous if the outputs of $ \gen_{sign} $ and $ \gen_W $ are pseudo-random.
%	%TODO define this more formally.
%\end{definition}


%
%Below, we define the real-world execution of a ring VRF.
%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
%	%TODO ADD anonymous key here
%	A ring VRF is a VRF with a  function $ F(.):\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
%	
%	\begin{itemize}
	%		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pk)$ where $ \kappa $ is the security parameter,
	%	\end{itemize}
%	Given list of public keys $ \ring = \set{\pk_1, \pk_2, \ldots, \pk_n}$, a message $ m \in \{0,1\}^{\ell_m} $
%	\begin{itemize}
	%		\item $ \rvrf.\eval(\skrvrf_i, \ring, m) \rightarrow y$
	%		\item $ \rvrf.\sign(\skrvrf_i, \ring, m)\rightarrow (\sigma,W) $ where  $\sigma $ is a signature of the message $ m $ signed by $ \skrvrf_i, \ring $ and $ W $ is an anonymous key.
	%		\item $ \rvrf.\verify(\ring,W, m,\sigma) \rightarrow  (b, y)$ where $ b \in \{0,1\} $ and $ y \in \{0,1\}^{\ell_\rvrf}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
	%%		\item $ \rvrf.\link(\skrvrf_i, \ring,W,m, \sigma) \rightarrow \hat\sigma $ where  $ \hat\sigma $ is a signature that links signer of the ring signature $ \sigma $. 
	%%		\item $ \rvrf.\link\verify( \pk_i,\ring,W, m, \sigma, \hat\sigma)\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
	%	\end{itemize}
%	
%\end{definition}
