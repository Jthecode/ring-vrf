\subsection{Ring VRF in the UC Model}

In Figure \ref{f:gvrf}, we give a UC functionality $\fgvrf$ for ring VRFs,
which we ourselves shall use in other works.  In $\fgvrf$, we suppress
auxiliary data and ring commitment details to make our UC functionality
more accessible, meaning our ring commitment is simply the full ring both
here and in Appendix \ref{???}.

We give several important remarks that help elucidate $\fgvrf$:

First, Each party is distinguished by unique verification key which is given by the simulator. Verification keys have the identifier role of  the signatures and outputs rather than  influencing the value of them. Therefore, there exists no secret key as in the real world protocol.

Second, the verification algorithm of a ring VRF outputs the corresponding evaluation value of the verified signature. Therefore, $ \fgvrf $  outputs the corresponding output during the signature verification if the signature is verified. However, it achieves this together with the anonymous key which is not defined in the ring VRF in the real world.  If $ \fgvrf $ did not define an anonymous key of each signature, then there would be no way that $ \fgvrf $ determines the actual verification key of the signature $ \sigma $ and outputs the evaluation value because $ \sigma $ does not need to be associated with the signer's key or unique. Therefore, $ \fgvrf $ associates an anonymous key independent from the signer's key $ \pk $ for each $ m $ and $ \pk $ so that this key behaves as if it is the verification key of the signature during the verification.
	
Third, $ \fgvrf $ does not have a separate signing protocol for malicious parties as parties because they can generate it as they like. If they generate a signature, it is added to the $ \fgvrf $'s records as valid or invalid when a party comes for the verification of it.  Its validity depends on $ \simulator $ as it can be seen in \ref{cond:malicioussignature}. 
	
Fourth, once $ \simulator $ obtains an anonymous key of a message $ m $ generated for an honest party, we let $ \simulator $ learn the  evaluation of  $ m $ and  $ W $. $ \simulator $ can do this in $ \fgvrf $ in three ways: The first way is via malicious ring VRF evaluation i.e., send the message $ (\msg{eval}, \sid, \pk_i,W,m) $. Here, if $ W $ is an anonymous key of $ m, \pk  $, $ \fgvrf $ returns $ \evaluationslist[m, W] $ even if $ \pk \neq \pk_i $. $ \fgvrf $ returns it independent from which verification key given in $ \simulator $'s message. The second way is via malicious requests of signatures and outputs.  Here, $ \simulator $ also learns  all honest signatures of $ m $ generated for a given ring and anonymous key. The last way is via verification.  In a nutshell, evaluation of a message for an honest party is secret to $ \simulator $ till $ \simulator $ obtains the corresponding anonymous key.
	
% The functionality lets parties generate a key (Key Generation), evaluate a message with the party's key (Ring VRF Evaluation), sign a message by one of the keys (Ring VRF signature) and verify the signature and obtain the evaluation output without knowing the key used for the signature and evaluation (Ring VRF Verification). 
%
%%We also define linking procedures in $ \fgvrf $ to link a signature with its associated key. So, if a party wants to reveal its identity at some point, it can use the linking process to show that the evaluation is executed with its key (Linking Signature). Later on, anyone can verify the linking signature (Linking Verification).
%
%In a nutshell, the functionality $\fgvrf$, when given as input a message $m$ and a key set $\pkring$ (that we call a ring) of party, allows to create $n$ possible different outputs pseudo-random that appear independent from the inputs. The output can be verified to have been computed correctly by one of the participants in $\pkring$ without revealing who they are. At a later stage, the author of the ring VRF output can prove that the output was generated by him and no other participant could have done so.

We designed $ \fgvrf $ so that it achieves the following properties:

\paragraph{Randomness:}  The evaluation of $ (m, \pk_i) $,  which is $ \evaluationslist[m,W] $ where $ \anonymouskeymap[m,W] = \pk_i $, is random.

%Given that the evaluation of $  m, \pk  $ for any verification key $ \pk $ and for any message $ m $ has never been given to $ \simulator $, the probability that $ \simulator $ guesses the evaluation of $ m, \pk_i $ is $ \frac{1}{2^{\ell_\rvrf}} $, given that $  $

Each element in $ \Out $ are selected randomly by $ \fgvrf $. Therefore, $ \fgvrf $ satisfies randomness.  Evaluation of $ m, \pk_i $ where $ \pk_i $ is an honest key is generated by first assigning a random anonymous key $ W $ to it and then assigning a random evaluation value $ y $ to $ m, W $. Therefore, honest evaluations are always random. Malicious evaluation of $ m, \pk_i $, where $ \pk_i $ is not an honest verification key, is generated by first assigning an anonymous key $ W $ given by $ \simulator $ to it and then assigning a random value $ y $ to $ m, W $. Since $ \fgvrf $ checks whether $ W $ is an anonymous key of another verification key, evaluation of $ m, \pk_i $ is always random. If $ \fgvrf $ did not check this, then the evaluation of $ m, \pk_i $ would be the same as the evaluation of $ m, \pk_j  \neq \pk_i$ whose anonymous key is $ W $.


\paragraph{Determinism:} Once evaluation of $ (m, \pk_i) $, which is $ \evaluationslist[m,W] $ where $ \anonymouskeymap[m,W] = \pk_i $, is set, it cannot be changed. 

$ \fgvrf $ satisfies determinism because it checks whether $ (m, \pk_i) $ is evaluated before any time that it needs it. The only way for $ \simulator $ to change the evaluation of $ (m, \pk_i) $ is by changing the anonymous key of $ (m, \pk_i)  $ but the anonymous key cannot change once it is set i.e., $ \fgvrf $ always checks whether there exists $ W $ where $ \anonymouskeymap[m,W]  = \pk_i$ whenever it needs the evaluation value.

\paragraph{Anonymity:} An honest signature $ \sigma $ of a message $ m $ verified by a ring $ \pkring $ does not give any information about its signer except that its key is in $ \pk $.

$ \fgvrf $ satisfies anonymity. $ \simulator $ learns the signature of an honest party with an anonymous key $ W $ via malicious requests of signatures and outputs. Remark that $ W $ is sampled randomly and the signature generation algorithm $ \Gen_{sign} $ generates a signature independent from the public key and the message. Therefore, the signature does not give any information about its signer except that its key is one of the honest keys in  $ \pkring  $.

\paragraph{Unforgeability:}  If an honest party with a public key $ \pk $ never signs a message $ m $ for a ring $ \pkring $, then no party is able to generate a valid signature of $ m $ for $ \pkring $ signed by $ \pk $. 

We need verify that $ \sim $ cannot generate a signature $ \sigma $ that signs a message $ m $ for a ring $ \pkring $ by an honest party's key $ \pk $. In other words, we need to verify that if $ \fgvrf $ never received a message $ (\msg{sign}, \sid,\pkring,\pk,m) $ from an honest party $ \user $ with the key $ \pk $, $ \fgvrf $ cannot have a record $ [m, W, \pkring, \sigma, 1] $ such that $ \anonymouskeymap[m,W]  = \pk$ (meaning that $ \sigma $ is a valid signature generated by the honest key $ \pk $). 
$ \sim $ cannot execute the forgery attack by sending a message $ (\msg{sign}, \sid,\pkring,\pk,m) $ to $ \fgvrf $ because $ \fgvrf $ checks whether the sender of this message is associated with the key $ \pk $ to generate a signature. Another way for $ \sim $ to create a forgery is by sending an honest key $ \pk_\simulator $  in \ref{cond:malicioussignature}. However, it is not allowed by $ \fgvrf $ in \ref{cond:forgery}.


%
%to make $ \fgvrf $ set $ \anonymouskeymap[m,W] $ with an honest key for any $ m,W $.  Let's see whether this is possible. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature.

%
% to generate a valid signature is via verification i.e., when a party sends a message  $ (\msg{verify}, \sid,\pkring,W,m, \sigma) $ to $ \fgvrf $.  During the verification, if $ \fgvrf $ is in \ref{cond:differentsignature} and \ref{cond:simulatorbit} then the validity of the signature is decided by $ \simulator $. If $ \fgvrf $ is in \ref{cond:simulatorbit}, it means that there exists no $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H $ because if it existed, $ \fgvrf $ would be in \ref{cond:differentsignature}. Therefore, the signature verified in \ref{cond:simulatorbit} cannot be a signature of an honest party's key.  This means that $ \simulator $ cannot generate a forgery via \ref{cond:simulatorbit}. So, the only left way for $ \simulator $ to generate a forgery is via \ref{cond:differentsignature}.
%If $ \fgvrf $ is in \ref{cond:differentsignature}, then $ \anonymouskeymap[m,W] $ belongs to an honest party and another signature $ \sigma' \neq \sigma $ has already been stored as valid for $ W, \pkring, m $.  If $ \sigma' $ is not generated by this honest party, then it means that $ \simulator $ forges. Let's see whether this is possible. If there exists a record $ [m, W, \pkring, \sigma',1] $ , it means that $ \anonymouskeymap[m,W] = \pk \in \mathcal{P}_H$ exists. The places that $ \fgvrf $ can set $ \anonymouskeymap[m,W] = \pk $  is during ``malicious ring VRF evaluation", ``honest ring VRF signature and evaluation" and ``verification". Clearly, this event cannot happen via malicious ring VRF evaluation  because $ \pk $ is an honest key. It cannot happen via  ``honest ring VRF signature and evaluation''  because we assume that the party $ \user $ with the key $ \pk $ never asked for it. It cannot happen via ``verification'' because \ref{cond:forgery} prevents $ \simulator $ to generate an anonymous key for $ \pk $.      This shows us that $ \simulator $ cannot generate a signature via \ref{cond:differentsignature}.

\paragraph{Uniqueness:} The number of verified outputs via signatures for a message and a ring $ \pkring $ is not more than $ |\pkring| $.
 
 We need to verify that number of outputs for a message $ m $ that are verified by the ring $ \pkring $ is not greater than $ |\pkring| $.
Assume that there exist $ t + 1 $ verified signatures $ \setsym{S} = \{\sigma_1, \sigma_2, \ldots, \sigma_t\} $ of a message $ m $ for a ring $ \pkring $ where $ |\pkring| = t $ and $ \fgvrf $ outputs $ 1, y_i $ for each query $ (\msg{verify}, \sid, \pkring, W_i, m, \sigma_i) $ where $ y_i \neq y_j $ for all $ i \neq j $. For each $ \sigma_i \in \setsym{S} $, $ \anonymouskeymap[m,W_i] = \pk_i $ and $ \Out[m,W_i] = y_i $. Clearly, in this case, $ W_i \neq W_j $ for all $ i \neq j $ since $ y_i \neq y_j $ by our assumption. $ \fgvrf $ generates a signature for an honest party if the honest key is in the ring. Therefore, the number of anonymous keys (so that evaluation outputs) for the honest signatures is at most number of honest keys in $ \pkring $. Since we know that once anonymous key $ W_i $ is set for $ m, \pk_i $, it cannot be changed. This means that there exist at least $ |\pkring_{mal}| + 1 $ signatures in $ \setsym{S} $. When $ \fgvrf $ verifies a malicious signature, it checks in \ref{cond:uniqueness} whether the number of malicious anonymous keys for $ m $ are greater than the number of malicious keys in the corresponding ring. Therefore, the simulator can generate at most $ |\pkring_m| $ anonymous keys generate for a ring $ \pkring $. This implies that the number of verified outputs of malicious parties   is $ |\pkring|_m $. 

\paragraph{Robustness:} $ \simulator $ cannot prevent an honest party to evaluate, sign or verify.

The only place that $ \fgvrf $ does not respond any query is when it aborts. This happens only when it selects an honest anonymous key which already existed. Since this happens in negligible probability,  $ \fgvrf $ is robust.

%Now, we verify that $ \fgvrf $ satisfies these properties. During our analysis, when we say that a message $ m $ signed by an anonymous key $ W $ we mean that $ [m,W,.,.,1] $ is recorded. We say that the signature is honest if $ \anonymouskeymap[m,W] = \pk $ is an honest party's key.
%
%
%
%\paragraph{\textbf{Uniqueness:}}
%
%\paragraph{\textbf{Robustness:}} We check whether $ \simulator$ can prevent an honest party signing and verifying. $ \fgvrf $ does not abort during the verification so an honest party can verify all signatures. $ \fgvrf $ aborts during the honest signing process if $ \Gen_{sign}(m, \pkring) $ generates a signature which was invalidated before i.e., there exists a record $ [m, W, \pkring, \sigma,0] $.
%
%
%
%
%\begin{enumerate}[label={{R-} }{{\arabic*}}, start = 1]
%
%%\item The ring VRF signature does not need to be random but it must be \emph{unique}  for its ring and the message. The reason of it to have a mapping from a ring VRF signature to its evaluation output. The map is necessary for $ \fgvrf $ to output the corresponding evaluation value for the signature during the verification process i.e, $ [m, \pkring, \sigma] \rightarrow \pk, \evaluationsecretlist[m, \pkring][\pk] \rightarrow y $.
%\item In classical VRF, a VRF $ F $ is a deterministic function which maps a message and a public key to a random output. While in ring VRF, a message, a public key and a ring map to a random value, the verification algorithm of a ring VRF does not take the key as an input because it should be hidden. Therefore, the verification should be executed without the public key.  So, the functionality $ \fgvrf $ needs to find a way to verify the ring VRF output of a message, a public key and a ring map without knowing the public key. Because of this, $ \fgvrf $ generates an anonymized key $ W $ for each evaluation so that a message $ m $  and $ W $ maps to the random output. One can imagine this  as if a VRF output is generated with the input message $ m $ and the key $ W $ as in classical VRF i.e.,  $ F(m, W) $. 
%
%\item  If an honest party signs a message for a ring and obtains a signature, $ \fgvrf $ allows the simulator to generate another signature in \ref{cond:differentsignature} if the simulator wants. We remark that this is not a security issue because an honest party has already committed to sign the message.  A similar condition  exists in the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.
%
%\item \ref{cond:simulatorbit} of the ring VRF verification process covers the case where the adversary decides whether accepting the signature generated for its key if  it could be a valid signature for the ring i.e., the malicious key is in the ring and the anonymous key in the verification request is unique.
%
%\item The linking signature and the linking verification works similar to the EUF-CMA secure signature functionality $ \fsig $ \cite{canettiFsig}.


%\end{enumerate}


%\begin{definition}[Anonymous $ \fgvrf $]\label{def:anonymity}
%	We call that $ \fgvrf $ is anonymous if the outputs of $ \gen_{sign} $ and $ \gen_W $ are pseudo-random.
%	%TODO define this more formally.
%\end{definition}


%
%Below, we define the real-world execution of a ring VRF.
%\begin{definition}[Ring-VRF (rVRF)]\label{def:ringvrf}
%	%TODO ADD anonymous key here
%	A ring VRF is a VRF with a  function $ F(.):\{0,1\}^* \rightarrow \{0,1\}^{\ell_\rvrf} $ and with the following algorithms:
%	
%	\begin{itemize}
%		\item $ \rvrf.\keygen(1^\kappa) \rightarrow (\skrvrf,\pk)$ where $ \kappa $ is the security parameter,
%	\end{itemize}
%	Given list of public keys $ \pkring = \set{\pk_1, \pk_2, \ldots, \pk_n}$, a message $ m \in \{0,1\}^{\ell_m} $
%	\begin{itemize}
%		\item $ \rvrf.\eval(\skrvrf_i, \pkring, m) \rightarrow y$
%		\item $ \rvrf.\sign(\skrvrf_i, \pkring, m)\rightarrow (\sigma,W) $ where  $\sigma $ is a signature of the message $ m $ signed by $ \skrvrf_i, \pkring $ and $ W $ is an anonymous key.
%		\item $ \rvrf.\verify(\pkring,W, m,\sigma) \rightarrow  (b, y)$ where $ b \in \{0,1\} $ and $ y \in \{0,1\}^{\ell_\rvrf}\cup \{\perp\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
%%		\item $ \rvrf.\link(\skrvrf_i, \pkring,W,m, \sigma) \rightarrow \hat\sigma $ where  $ \hat\sigma $ is a signature that links signer of the ring signature $ \sigma $. 
%%		\item $ \rvrf.\link\verify( \pk_i,\pkring,W, m, \sigma, \hat\sigma)\rightarrow b$ where $ b \in \{0,1\} $. $ b =1 $ means verified and $ b = 0 $ means not verified.
%	\end{itemize}
%	
%\end{definition}
