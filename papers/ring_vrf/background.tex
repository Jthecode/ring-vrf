
\section{Background}
\label{sec:background}

We briefly establish elliptic curve notion and recall some standard
definitions and assumptions.
% underlying both Chaum-Pedersen DLEQ proofs and pairing based zkSNARKs.

% As our ring VRF is built by composing them,
% We briefly recall the primitives and security assumptions underlying
% both Chaum-Pedersen DLEQ proofs and pairing based zkSNARKs.


\subsection{Elliptic curves}

% As our ring VRF is built by composing them, 
% We briefly recall the primitives and security assumptions underlying
% both Chaum-Pedersen DLEQ proofs and pairing based zkSNARKs. 

We obey mathematical and cryptographic implementation convention by 
adopting additive notation for elliptic curve and multiplicative notation
for elliptic curve scalar multiplications.
%
All objects implicitly depend a security parameter \secparam.

We have an elliptic curve $\ecE$ over a field of characteristic $q$,
equipped with a type III pairing $e : \grE_1 \times \grE_2 \to \grE_T$,
where the groups  $\grE_1 \le \ecE[\F_q]$, $\grE_2 \le \ecE[\F_{q^2}]$, and
$\grE_T \le \F^*_{q^{12}}$ all have prime order $p \approx 2^{2\secparam}$.

We write $\grE$ when discussing the Chaum-Pedersen DLEQ proofs, which do
not employ pairings, but $\grE$ always denotes $\grE_1$ eventually.
We avoid pairing unfriendly assumptions like DDH of course, but really
we employ the algebraic group model (AGM) throughout.

We sweep cofactor concerns under the rug when discussing Groth16,
where pairings demand deserialization prove group membership in $\grE_1$
or $\grE_2$.  We explicitly multiply by the cofactor $h$ when doing
Chaum-Pedersen DLEQ proofs though, as not doing so risks miss-readings by implementers.

We also let $\ecJ$ denote a ZCash Sapling style ``JubJub'' Edwards curve
over $\F_p$, with distinguished subgroup $\grJ$ of prime order, so that
SNARKs on $\ecE$ prove $\grJ$ arithmetic relatively cheaply.
Aside from Jubjub, we optionally want a ``sister'' Edwards curve $\crE$,
with a subgroup $\grE$ of the same order $p$ $\grE$, but which lacks any pairing.

We let $H_p : \{0,1\}^* \to \F_p$ and $H_{\grE} : \{0,1\}^* \to \grE_1$
denote hash-to-scalar and hash-to-curve random oracles (RO) with ranges
$\F_p$ and $\grE'$, respectively.  


\subsection{Zero-knowledge proofs}
\label{subsec:zkp_background}

% refs.
% https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Zero%20Knowledge/Noninteractive_Zero-Knowkedge.pdf
%   Alright but kinda poorly phrases
% https://inst.eecs.berkeley.edu/~cs276/fa20/notes/Multiple%20NIZK%20from%20general%20assumptions.pdf
%   Addresses the ZK definitions better
% 

We let \rel denote a polynomial time decidable relation, so the language
$\lang = \{x \mid \exists \omega (\omega,x) \in \rel \}$ lies in NP.
All non-interactive zero-knowledge proof systems have some setup procedure $\mathtt{Setup}$ that takes our parameters generated by $\mathtt{Params}$ and some ``circuit'' description of \lang, and produces a structured reference string (SRS).

A non-interactive proof system for $\lang$ consists of \Prove and \Verify PPT algorithms
\begin{itemize}
%\item $\NIZK.\setup(\rel) \rightarrow (crs, \tau)$ ---- Given the relation $ \rel $ it outputs a common reference string $ crs $ and a trapdoor $ \tau $ for $ \rel $.
\item $\NIZK_\rel.\Prove(\omega, x) \mapsto \pi$ creates a proof $\pi$ for a witness and statement pair $(\omega,x) \in \rel$.
\item $\NIZK_\rel.\Verify(x, \pi)$ returns either true of false, depending upon whether $\pi$  proves $x$.
\end{itemize}	
which satisfy the following completeness, zero-knowledge, and knowledge soundness definitions.
We always write $\NIZK_\lang$ in practice because other notation always obfuscates the actual relation \rel.

\begin{definition}\label{def:nizk_completeness}
We say $\NIZK_\rel$ is {\em complete} if $\Verify(x, \Prove(\omega,x)$ succeeds for all $(\omega,x) \in \rel$.  % with high probability
\end{definition}

\def\advV{\ensuremath{V^*}\xspace} % Why not use \adv here?

\begin{definition}\label{def:nizk_zero_knowledge}
We say $\NIZK_\rel$ is {\em zero-knowledge} if
there exists a PPT simulator $\NIZK_\rel.\Simulate(x) \mapsto \pi$
that outputs proofs for statement $x \in L$ alone, which are
computationally indistinguishable from legitimate proofs by \Prove,
i.e.\ any non-uniform PPT adversary \advV cannot distinguish pairs $(x,\pi)$
generated by \Simulate or by \Prove except with odds negligible in \secparam
(see \cite[Def. 9, \S A, pap. 29]{RandomizationGroth16}). %  or ...
\end{definition}

\def\advP{\ensuremath{P^*}\xspace} % Why not use \adv here?

\begin{definition}\label{def:nizk_knowledge_sound}
We say $\NIZK_\rel$ is {\em (white-box) knowledge sound} if
for any non-uniform PPT adversary \adv who outputs a statement $x \in \lang$ and proof $\pi$
there exists a PPT extractor algorithm $\Extract$ that white-box observes $\advP$ and
if $\Verify(x,\pi)$ holds then $\Extract$ returns an $\omega$ for which $(\omega,x) \in \rel$
(see \cite[Def. 7, \S A, pap. 29]{RandomizationGroth16}).
\end{definition}

Our zero-knowledge continuations in \S\ref{sec:rvrf_cont} demand
rerandomizing existing zkSNARKs, which only Groth16 supports \cite{Groth16}.
We therefore introduce some details of Groth16 \cite{Groth16} there,
when we tamper with Groth16's SRS and $\mathtt{Setup}$ to create zero-knowledge continuations. 
% TODO: Do we describe Groth16 \cite{Groth16} enough?

% In this, we exploit several arguments given by \cite{RandomizationGroth16},
% but for now we recall that \cite{RandomizationGroth16} proves that Groth16
% satisfies: % white-box weak simulation-extractablity .
%
% \begin{definition}\label{def:nizk_weak_simulation_extractable}
	% We say $\NIZK_\rel$ is {\em white-box weak simulation-extractable} if
	% for any non-uniform PPT adversary \advP with oracle access to \Simulate
	% who outputs a statement $x \in \lang$ and proof $\pi$,
	% there exists a PPT extractor algorithm $\Extract$ that white-box observes $\advP$ and
	% if \advP never queried $x$ and $\Verify(x,\pi)$ holds
	% then $\Extract$ returns an $\omega$ for which $(\omega,x) \in \rel$
	% (see \cite[Def. 7, \S 2.3, pap. 29]{RandomizationGroth16}).
	% \end{definition}

% TODO: AGM and Groth16 here?


\subsection{Universal Composability (UC) Model}
\label{subsec:uc_background}
We define the security of ring VRFs in the UC model \cite{canetti1,canetti2}. In a nutshell, Canetti \cite{canetti1,canetti2} defines the UC model as follows:

A protocol $ \phi $ in the UC model is an execution between distributed interactive Turing machines (ITM). Each ITM has a storage to collect the incoming messages from other ITMs, adversary \adv or the environment $ \env $. $ \env $ is an entity to represent the external world outside of the protocol execution.  The environment $ \env $ initiates ITM instances (ITIs) and the adversary \adv with arbitrary inputs and then terminates them to collect the outputs.
% An ITM that is initiated by $ \env $ is called ITM instance (ITI). 
We identify an ITI with its session identity $ \sid $ and its ITM's identifier $ \pid $. In this paper, when we call an entity as a party in the UC model we mean an ITI with the identifier $ (\sid, \pid) $.

We define the ideal world where there exists an ideal functionality $ \mathcal{F} $ and the real world where a protocol $ \phi $ is run as follows:

\paragraph{Real world:} $ \env $ initiates ITMs and \adv to run the protocol instance with some input $ z \in \{0,1\}^* $  and a security parameter $ \secparam $. After $ \env $ terminates the protocol instance, we denote the output of the real world by the random variable $ \mathsf{EXEC}(\secparam, z)_{\phi, \adv, \env} \in \{0,1\} $. Let $ \mathsf{EXEC}_{\phi, \adv, \env} $ denote the ensemble $ \{\mathsf{EXEC}(\secparam, z)_{\phi, \adv, \env} \}_{z \in \{0,1\}^*} $.

\paragraph{Ideal world:} $ \env $ initiates ITMs and a simulator $ \simulator $ to contact with the ideal functionality $ \mathcal{F} $ with some input $ z \in \{0,1\}^* $  and a security parameter $ \secparam $. $ \mathcal{F} $ is trusted meaning that it cannot be corrupted.
$ \simulator $ forwards all messages forwarded by $ \env $ to $ \mathcal{F} $. The output of execution with $ \mathcal{F} $ is denoted by a random variable $ \mathsf{EXEC}(\secparam, z)_{\mathcal{F},\simulator, \env} \in \{0,1\}$.  Let $ \mathsf{EXEC}_{\mathcal{F},\simulator, \env} $ denote the ensemble $ \{\mathsf{EXEC}(\secparam, z)_{\mathcal{F}, \simulator, \env} \}_{z \in \{0,1\}^*} $.

%TODO: \secparam should likely be implicit, especially since it appears in both worlds.

\begin{definition}[UC-Security of $ \phi $] \label{def:uc}
	Given a real world protocol $ \phi $ and an ideal functionality $ \mathcal{F} $ for the protocol $ \phi $, we call that $ \phi $ is UC-secure i.e., $ \phi $ UC-realizes $ \mathcal{F} $, if for all PPT adversaries \adv,  there exists a simulator $ \simulator  $ such that for any environment $ \env $,
	$\mathsf{EXEC}_{\phi, \adv, \env}$ is indistinguishable from $\mathsf{EXEC}_{\mathcal{F},\simulator, \env}$.
\end{definition}



%\begin{definition}[UC-Security of $ \phi $ in the hybrid world]
%	Given a real world protocol $ \phi $ which runs some (polynomially many) functionalities $ \{\mathcal{F}_1, \mathcal{F}_2, \ldots, \mathcal{F}_k\} $ in the ideal world and an ideal functionality $ \mathcal{F} $ for the protocol $ \phi $, we call that $ \phi $ is UC-secure in the hybrid model $ \{\mathcal{F}_1, \mathcal{F}_2, \ldots, \mathcal{F}_k\} $ if $ \phi $ UC-realizes $ \mathcal{F} $ if for all PPT adversaries \adv, there exists a simulator $ \simulator  $ such that for any environment $ \env $,
%	$\mathsf{EXEC}_{\phi, \adv, \env}$ is indistinguishable from $\mathsf{EXEC}_{\mathcal{F},\simulator, \env}$.
%\end{definition}

% REMARKS:  Removed excessive notation $\approx$.

