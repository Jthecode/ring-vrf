\begin{figure}\scriptsize
	\begin{tcolorbox}
		{  $ \fgvrf $ runs two PPT algorithms $ \gen_W$ and $\gen_{sign} $ during the execution.
			
			 \begin{description}
				
				\item[Key Generation.] upon receiving a message $(\msg{keygen}, \sid)$ from a party $\user_i$, send $(\msg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
				Upon receiving a message $(\msg{verificationkey}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ has not been recorded before; then, store in the table $\vklist$, under $\user_i$, the value $\pkrvrf$.
				Return $(\msg{verificationkey}, \sid, \pkrvrf)$ to $ \user_i$.
				
				\item[Malicious Key Generation.] upon receiving a message $(\msg{keygen}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ was not yet recorded, and if so record in the table $\vklist$ the value $\pkrvrf$ under $\simulator$. Else, ignore the message.
				
				%\item[Honest Ring VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that 
				%$\pkrvrf_i \in \pkring$ 
				%and  
				%there exists $ \pkrvrf_i $ in $\vklist $ associated with $ \user_i $. If that was not the case, just ignore the request.
				%If there exists no $ W $ such that $ \anonymouskeymap[W] = (m, \pkring, \pkrvrf_i) $, let $ W \sample \bin^\secpar $ and  $y \sample \bin^{\ell_\rvrf}$. Then, set $ \evaluationslist[m, W] = y$ and $ \anonymouskeymap[W] = (m, \pkring,\pkrvrf_i) $.
				%Return $(\msg{evaluated}, \sid, \pkring, m, W, y)$ to $ \user_i $.
				%The functionality does not check whether the evaluater's public key is in the ring because here we consider m, \pkring as an input of the evaluation which is evaluated by a party who is not neccesarily in the ring. 
				\item[Malicious Ring VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkring, \pkrvrf_i, W, m)$ from $\sim$, verify that $ \pkrvrf_i $ has not been recorded under an honest party's key.
			    If it is the case record in the table $\vklist$ the value $\pkrvrf_i$ under $\simulator$. Else, ignore the request.  If $ \counter[m,\pkring] $ does not exist, initiate $ \counter[m,\pkring] = 0 $.
			    If there exists $ W $ such that $ \anonymouskeymap[W] = (m',\pkring', \pkrvrf)$ then do the following:
			    \begin{itemize}
			    	\item if $(m', \pkring', \pkrvrf) \neq  (m, \pkring, \pkrvrf_i)  $, ignore the request,
			    	\item else obtain $ y = \evaluationslist[m, W]   $. 
			    \end{itemize}
				If there exists no $ W $ such that $ \anonymouskeymap[W] = (m, \pkring, \pkrvrf_i) $, let   $y \sample \bin^{\ell_\rvrf}$ and increment $ \counter[m,\pkring] $. Then, set $ \evaluationslist[m, W] = y$, $ \anonymouskeymap[W] = (m, \pkring,\pkrvrf_i) $ .
				Return $(\msg{evaluated}, \sid, \pkring, m, W, y)$ to $ \user_i $.
				
				
				
				
				\item[Honest Ring VRF Signature.] upon receiving a message $(\msg{sign}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and that there exists a public key $\pkrvrf_i$ associated to $\user_i$ in the table $ \vklist $. If that wasn't the case, just ignore the request. 	
				If there exists no $ W' $ such that $ \anonymouskeymap[W'] = (m, \pkring, \pkrvrf_i) $, run $ \gen_W(\pkring, \pkrvrf_i, m) \rightarrow W$. Then, let $y \sample \bin^{\ell_\rvrf}$ and set $ \anonymouskeymap[W] = (m, \pkring,\pkrvrf_i) $ and set $ \evaluationslist[m, W] = y$.
%					\begin{itemize}
%						%\item If there exists $ W \in  \anonymouskeymap  $, abort.
%						\item Else 
%						%TODO define what \in \anonymouskeymap mean
%					\end{itemize}
%			    \end{itemize}
				Obtain $ W, y $ where  $ \evaluationslist[m, W] = y$, $ \anonymouskeymap[W] = (m, \pkring,\pkrvrf_i) $ and run  $ \gen_{sign}(\pkring, W, m) \rightarrow \sigma $. Verify that $ [m, W, \sigma, 0] $ is not recorded. If not, abort. Otherwise, record $ [m, W, \sigma, 1] $. Return $(\msg{signature}, \sid, \pkring,W,m, y, \sigma)$ to $\user_i$.
				
				%\item[Malicious VRF evaluation.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, m)$ from $\simulator$, check that $\vklist$ has a public key associated to $\simulator$. If not, ignore the request. If $\evaluationslist[\pkring, m][\simulator]$ is not set, sample $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\simulator] \defeq y$ (and $\signaturelist[\pkring,m]$ to $\emptyset$). If $\signaturelist[\pkring, m]$ contains a proof (i.e., if $\signaturelist[\pkring, m]$ is not empty), return $(\msg{evaluated}, \sid, y)$ to $\simulator$. Else, ignore the request.
				
				%\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \sigma)$, from any party forward the message to the simulator. If there exists a $\pkrvrf_i$ among the values of \texttt{verification\_keys}, and there exists $\sigma \in \signaturelist[\pkring, m]$, set $b = 1$. Else, set $b =0$. Finally, output $(\msg{verified}, \sid, \pkring, m, y, \sigma, b)$.
				\item[Ring VRF Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring,W, m, \sigma)$ from a party, relay the message $(\msg{verify}, \sid, \pkring,W, m, \sigma)$ to $ \simulator $ and receive back the message $(\msg{verified}, \sid, \pkring,W, m, \sigma, b_{\simulator}, \pkrvrf_\simulator)$. Then do the following: 
				\begin{enumerate}[label={{Cond.-} }{{\arabic*}}, start = 1]
					\item If there exits a record $ [m,W,\sigma, 1] $, set $ b = 1 $. (This condition guarantees the completeness meaning that if  $ W $ is an anonymous key that is generated for the ring $ \pkring $ and  the message $ m $ and the signature $ \sigma $ is legitimately generated for $ m, W $, then the verification succeeds.)
					\item Else if $ \pkrvrf  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pkrvrf) $ and there exists no record $ [m, \pkring, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= 0  $.
					(This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \pkring $, then the verification fails.)\label{cond:forgery}
					\item Else if there exists a record  such as $ [m,W,\sigma, b'] $, set $ b = b' $. (This condition guarantees consistency meaning that all identical verification requests will output the same $ b $) \label{cond:consistency}
					\item Else if $ \pkrvrf  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pkrvrf) $ and there exists a record $ [m, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= b_{\simulator} $ and record $ [m, W,\sigma, b_{\simulator}] $. (This condition guarantees that if $ m $ is signed by an honest party for the ring $ \pkring $ at some point and the signature is $ \sigma' \neq \sigma $, then the decision of verification is up to the adversary) \label{cond:differentsignature}
					\item \label{cond:forgerymalicious}Else if there exists $ \anonymouskeymap[W] = (m', \pkring',.)  $ where $ (m', \pkring') \neq (m, \pkring) $ or $ \counter[m, \pkring] > |\pkring_m| $ where $ \pkring_m $ is a set of keys in $ \pkring $ which are not honest or $ b_{\simulator} = 0 $ or $ \pkrvrf_\simulator $ belongs to an honest party, set $ b = 0 $ and record $ [m, \pkring,W,\sigma, 0] $. (This condition guarantees that if $ W $ is an anonymous key of a different message and ring or the number of anonymous keys of malicious parties in $ \pkring $ is more than their number or     $ \simulator $ does not verify $ \sigma $, then the verification fails.)
					\item Else set $ b = 1 $. Set $ \evaluationslist[m, W]\sample \bin^{\ell_\rvrf}$, $ \anonymouskeymap[W]  = (m, \pkring, \pkrvrf_\simulator)$ and $ \counter[m, \pkring, \pkrvrf_\simulator] = 0 $ if they are not defined before. Increment $ \counter[m, \pkring, \pkrvrf_\simulator]  $. \label{cond:advsignature}
				\end{enumerate}
				In the end, if $ b = 0 $, set $ \out = \emptyset $. Otherwise,  set $ \out = \evaluationslist[m, W]$. 		Finally, output $(\msg{verified}, \sid, \pkring,W, m, \sigma, \out, b)$ to the party.
				
			\end{description}
		
			
		}
	\end{tcolorbox}
	\caption{Functionality $\fgvrf$.\label{f:gvrf}}
\end{figure}
	


\begin{figure}\scriptsize
	\begin{tcolorbox}
		{  This part of $ \fgvrf $ for the parties who want to show that they generate a particular ring signature.
			
		
			\begin{description}
				\item[Linking signature.] upon receiving a message $(\msg{link}, \sid, \pkring, \pkrvrf_i, W, m,\sigma)$ from $\user_i$, check that $\pkrvrf_i $ is associated to $\user_i$ in $ \vklist $, $ \anonymouskeymap[W] = (m, \pkring, \pkrvrf_i) $ and 
				check whether $ [m, W, \sigma, 1] $ is stored. If any of them fails, ignore the request. Otherwise,
				send $(\msg{link}, \sid, \pkring, W, m, y)$ to $\simulator$. Upon receiving $(\msg{linkproof}, \sid, \pkring, W, m, y, \hat \sigma)$ from $\simulator$, verify that $ [m, \pkring, \pkrvrf_i, \sigma, \hat{\sigma}, 0] $ is not stored in $ \Linklist $. If not, abort. Otherwise,  record $\hat\sigma$ to $[m, \pkring, \pkrvrf_i,\sigma, \hat{\sigma}, 1]$ to $ \Linklist $ and return $(\msg{linked}, \sid, \pkring, \pkrvrf_i,W, m, y,\sigma, \hat\sigma)$ to $\user_i$.
				%\item[Malicious linking proof.] upon receiving a message $(\msg{link}, \sid, \pkring, m, y)$ from $\simulator$, check that $\vklist$ has a key set for $\simulator$, and that it is in $R$.
				%Check that $\evaluationslist[\pkring, m][\simulator] = y$.
				%If any of the above is not satisfied, ignore the request.
				%Return $(\msg{linked}, \sid, y)$ to $\simulator$.
				\item[Linking verification.] upon receiving a message $(\msg{verifylink}, \sid, \pkrvrf_i, \pkring, W, m,\sigma,\hat\sigma)$ from any party forward the message to the simulator and receive back  the message $(\msg{verified}, \sid, \pkrvrf_i, \pkring, W,m, \sigma,\hat\sigma,  b_{\simulator})$. Then do the following:
				
				\begin{itemize}
					\item If there exits a record $ [m, \pkring,\pkrvrf_i,\sigma,\hat\sigma, 1] $ in $ \Linklist $, set $ b = 1 $ and $ \pk = \pkrvrf $. (This condition guarantees the completeness.)
					\item Else if $ \pkvrf_i $ is a key of an honest party and there exits no record such as $ [m, \pkring,\pkrvrf_i,\sigma,\hat\sigma',  1] $ for any  $  \hat\sigma'$, then set $ b = 0 $ and record $ [m, \pkring,\pkrvrf_i,\sigma,\hat\sigma,  0] $. (This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ in the linking signature, then the verification fails.)
					\item Else if there exists a record  such as $ [m, \pkring,\pkrvrf_i,\sigma,\hat\sigma,  b'] $, set $ b = b' $. 
					\item Else set $ b = b_{\simulator} $ and record $ [m, \pkring,\pkrvrf_i,\sigma,\hat\sigma,  1] $. 
				\end{itemize}
				
				Return $(\msg{verified}, \sid, \pkrvrf_i, \pkring, m, \hat\sigma, b).$ to the party.
			\end{description}
		}
	\end{tcolorbox}
	\caption{Functionality $\fgvrf$.\label{f:gvrf}}
\end{figure}


