
\section{Background}
\label{sec:thin_background}

% As our ring VRF is built by composing them, 
We briefly recall the primitives and security assumptions underlying
both Chaum-Pedersen DLEQ proofs and pairing based zkSNARKs. 
% Appendix \ref{sec:extra_background} provides standard background material.
% but a brief summary goes:

\subsection{Elliptic curves}

We obey mathematical and cryptographic implementation convention by 
adopting additive notation for elliptic curve and multiplicative notation
for elliptic curve scalar multiplications.
%
All objects implicitly depend a security parameter \secparam.

We have an elliptic curve $\ecE$ over a field of characteristic $q$,
equipped with a type III pairing $e : \grE_1 \times \grE_2 \to \grE_T$,
where the groups  $\grE_1 \le \ecE[\F_q]$, $\grE_2 \le \ecE[\F_{q^2}]$,
and $\grE_T \le \F^*_{q^{12}}$ all have prime order $p \approx 2^{2\secparam}$.

We write $\grE$ when discussing subprotocols not dependent upon the
pairing, but $\grE$ always denotes $\grE_1$ eventually.
We avoid pairing unfriendly assumptions like DDH of course, but really
we employ the algebraic group model (AGM) throughout.
We sweep cofactor concerns under the rug too, de facto assuming
deserialization prove elements of $\grE_1$ or $\grE_2$.

We let $H_p : \{0,1\}^* \to \F_p$ and $H_\grE : \{0,1\}^* \to \grE_1$
denote hash-to-scalar and hash-to-curve random oracles (RO) with ranges
$\F_p$ and $\grE$, respectively.  

We also let $\ecJ$ denote a ZCash Sapling style ``JubJub'' Edwards curve
over $\F_p$, with distinguished subgroup $\grJ$ of prime order, so that
SNARKs on $\ecE$ prove $\grJ$ arithmetic relatively cheaply.


\subsection{Zero-knowledge proofs}

\newcommand\rel{\ensuremath{\mathcal{R}}\xspace}
\newcommand\lang{\ensuremath{\mathcal{L}}\xspace}

% refs.
% https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Zero%20Knowledge/Noninteractive_Zero-Knowkedge.pdf
%   Alright but kinda poorly phrases
% https://inst.eecs.berkeley.edu/~cs276/fa20/notes/Multiple%20NIZK%20from%20general%20assumptions.pdf
%   Addresses the ZK definitions better
% 

We let \rel denote a polynomial time decidable relation, so the language
 $\lang = \{x \mid \exists \omega (\omega,x) \in \rel \}$ lies in NP.
All non-interactive zero-knowledge proof systems have some setup procedure $\mathtt{Setup}$ that takes our parameters generated by $\mathtt{Params}$ and some ``circuit'' description of \rel, and produces a structured reference string (SRS).

A non-interactive proof system for $\rel$ consists of \Prove and \Verify PPT algorithms
\begin{itemize}
%\item $\NIZK.\setup(\rel) \rightarrow (crs, \tau)$ ---- Given the relation $ \rel $ it outputs a common reference string $ crs $ and a trapdoor $ \tau $ for $ \rel $.
\item $\NIZK_\rel.\Prove(\omega, x) \mapsto \pi$ creates a proof $\pi$ for a witness and statement pair $(\omega,x) \in \rel$.
\item $\NIZK_\rel.\Verify(x, \pi)$ returns either true of false, depending upon whether $\pi$  proves $x$.
\end{itemize}	
which satisfy the following completeness, zero-knowledge, and knowledge soundness definitions.

\begin{definition}\label{def:nizk_completeness}
We say $\NIZK_\rel$ is {\em complete} if $\Verify(x, \Prove(\omega,x)$ succeeds for all $(\omega,x) \in \rel$.  % with high probability
\end{definition}

\def\advV{\ensuremath{V^*}\xspace} % Why not use \adv here?

\begin{definition}\label{def:nizk_zero_knowledge}
We say $\NIZK_\rel$ is {\em zero-knowledge} if
there exists a PPT simulator $\NIZK_\rel.\Simulate(x) \mapsto \pi$
that outputs proofs for statement $x \in L$ alone, which are
computationally indistinguishable from legitimate proofs by \Prove,
i.e.\ any non-uniform PPT adversary \advV cannot distinguish pairs $(x,\pi)$
generated by \Simulate or by \Prove except with odds negligible in \secparam
(see \cite[Def. 9, \S A, pap. 29]{RandomizationGroth16}). %  or ...
\end{definition}

\def\advP{\ensuremath{P^*}\xspace} % Why not use \adv here?

\begin{definition}\label{def:nizk_knowledge_sound}
We say $\NIZK_\rel$ is {\em (white-box) knowledge sound} if
for any non-uniform PPT adversary \adv who outputs a statement $x \in \lang$ and proof $\pi$
there exists a PPT extractor algorithm $\Extract$ that white-box observes $\advP$ and
if $\Verify(x,\pi)$ holds then $\Extract$ returns an $\omega$ for which $(\omega,x) \in \rel$
(see \cite[Def. 7, \S A, pap. 29]{RandomizationGroth16}).
\end{definition}

Our zero-knowledge continuations in \S\ref{sec:rvrf_cont} demand
rerandomizing existing zkSNARKs, which only Groth16 supports \cite{Groth16}.
We therefore introduce some details of Groth16 \cite{Groth16} there,
when we tamper with Groth16's SRS and $\mathtt{Setup}$ to create zero-knowledge continuations. 
% TODO: Do we describe Groth16 \cite{Groth16} enough?

% In this, we exploit several arguments given by \cite{RandomizationGroth16},
% but for now we recall that \cite{RandomizationGroth16} proves that Groth16
% satisfies: % white-box weak simulation-extractablity .
%
% \begin{definition}\label{def:nizk_weak_simulation_extractable}
% We say $\NIZK_\rel$ is {\em white-box weak simulation-extractable} if
% for any non-uniform PPT adversary \advP with oracle access to \Simulate
% who outputs a statement $x \in \lang$ and proof $\pi$,
% there exists a PPT extractor algorithm $\Extract$ that white-box observes $\advP$ and
% if \advP never queried $x$ and $\Verify(x,\pi)$ holds
% then $\Extract$ returns an $\omega$ for which $(\omega,x) \in \rel$
% (see \cite[Def. 7, \S 2.3, pap. 29]{RandomizationGroth16}).
% \end{definition}

TODO: AGM and Groth16 here?


\subsection{Universal Composability (UC) Model}

TODO: Chat on why UC is here?

A protocol $ \phi $ in the UC model is an execution between distributed interactive Turing machines (ITM). Each ITM has a storage to collect the incoming messages from other ITMs, adversary \adv or the environment $ \env $. $ \env $ is an entity to represent the external world outside of the protocol execution.  The environment $ \env $ initiates ITM instances (ITIs) and the adversary \adv with arbitrary inputs and then terminates them to collect the outputs.
% An ITM that is initiated by $ \env $ is called ITM instance (ITI). 
We identify an ITI with its session identity $ \sid $ and its ITM's identifier $ \pid $. In this paper, when we call an entity as a party in the UC model we mean an ITI with the identifier $ (\sid, \pid) $.

We define the ideal world where there exists an ideal functionality $ \mathcal{F} $ and the real world where a protocol $ \phi $ is run as follows:

\paragraph{Real world:} $ \env $ initiates ITMs and \adv to run the protocol instance with some input $ z \in \{0,1\}^* $  and a security parameter $ \secparam $. After $ \env $ terminates the protocol instance, we denote the output of the real world by the random variable $ \mathsf{EXEC}(\secparam, z)_{\phi, \adv, \env} \in \{0,1\} $. Let $ \mathsf{EXEC}_{\phi, \adv, \env} $ denote the ensemble $ \{\mathsf{EXEC}(\secparam, z)_{\phi, \adv, \env} \}_{z \in \{0,1\}^*} $.

\paragraph{Ideal world:} $ \env $ initiates ITMs and a simulator $ \sim $ to contact with the ideal functionality $ \mathcal{F} $ with some input $ z \in \{0,1\}^* $  and a security parameter $ \secparam $. $ \mathcal{F} $ is trusted meaning that it cannot be corrupted.
$ \sim $ forwards all messages forwarded by $ \env $ to $ \mathcal{F} $. The output of execution with $ \mathcal{F} $ is denoted by a random variable $ \mathsf{EXEC}(\secparam, z)_{\mathcal{F},\sim, \env} \in \{0,1\}$.  Let $ \mathsf{EXEC}_{\mathcal{F},\sim, \env} $ denote the ensemble $ \{\mathsf{EXEC}(\secparam, z)_{\mathcal{F}, \sim, \env} \}_{z \in \{0,1\}^*} $.

TODO: \secparam should likely be implicit, especially since it appears in both worlds.

\begin{definition}[UC-Security of $ \phi $] \label{def:uc}
Given a real world protocol $ \phi $ and an ideal functionality $ \mathcal{F} $ for the protocol $ \phi $, we call that $ \phi $ is UC-secure if $ \phi $ UC-realizes $ \mathcal{F} $ if for all PPT adversaries \adv, there exists a simulator $ \sim  $ such that for any environment $ \env $,
 $\mathsf{EXEC}_{\phi, \adv, \env}$ indistinguishable from $\mathsf{EXEC}_{\mathcal{F},\sim, \env}$
\end{definition}

TODO: if ... if makes no sense.  These definitions need much clearer explanation, or more likely citations to places with clear explanations. 

\begin{definition}[UC-Security of $ \phi $ in the hybrid world]
Given a real world protocol $ \phi $ which runs some (polynomially many) functionalities $ \{\mathcal{F}_1, \mathcal{F}_2, \ldots, \mathcal{F}_k\} $ in the ideal world and an ideal functionality $ \mathcal{F} $ for the protocol $ \phi $, we call that $ \phi $ is UC-secure in the hybrid model $ \{\mathcal{F}_1, \mathcal{F}_2, \ldots, \mathcal{F}_k\} $ if $ \phi $ UC-realizes $ \mathcal{F} $ if for all PPT adversaries \adv, there exists a simulator $ \sim  $ such that for any environment $ \env $,
 $\mathsf{EXEC}_{\phi, \adv, \env}$ is indistinguishable from $\mathsf{EXEC}_{\mathcal{F},\sim, \env}$.
\end{definition}

% REMARKS:  Removed excessive notation $\approx$.





\endinput



BROKEN BOLOW THIS




We fix $J \in \ecJ$ as a generator for public keys.  Any $\KeyGen$ algorithm randomly samples a secret keys $\sk \in \F_q$ and then computes its associate public keys $\pk = \sk J$.  We shall not discuss infrastructure that authorizes public keys.  Yet although our results do not require proof-of-knowledge on $\pk$ per se, we still strongly recommend that back certifications accompany any certificates that authorize $\pk$.

\smallskip




