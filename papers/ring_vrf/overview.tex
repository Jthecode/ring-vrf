\section{Protocol overview}
\label{sec:overview}

As a beginning, we introduce the ring VRF interface, give a simple
unamortized non-interactive zero-knowledge (NIZK) protocol that
realizes the ring VRF properties discussed later in our UC model,
and give some intuition for our later amortization trick.
Similar to VRF \cite{vrf_micali}, a ring VRF construction needs: 

\begin{itemize}
\item $\rVRF.\KeyGen : (1^{\lambda}) \mapsto (\sk, \pk)$ algorithm,
 which creates a random secret key \sk and associated public key \pk;

\item $\rVRF.\Eval : (\sk,\msg) \mapsto \Out$ which deterministically computes the VRF output \Out from a secret key \sk and a message \msg.
\end{itemize}
%
% Although many constructions exist,
%Our \rVRF.\KeyGen and \rVRF.\Eval initially resemble EC VRFs like \cite{nsec5,VXEd25519,draft-irtf-cfrg-vrf-10}.
% In other words,
% internally we prove a VUF output $\PreOut = \sk H_{\grE}(\msg)$,
% with a hash-to-curve $H_{\grE}$, so then applying a PRF $H'$ yields a
% VRF output $\Out = H'(\msg, h \PreOut)$ ala \cite[Prop. 1]{vrf_micali},
% using a key pair like $\pk = \sk \genG$ for a generator $\genG$.

%We demand pseudo-randomness properties from \Eval, which could mirror
%\cite{vrf_micali} if desired.  We provide a UC definition resembling
%\cite{praos,ucvrf} which handles adversarial keys better however. %NOT CLEAR WHAT HANDLING BETTER MEANS

We demand a pseudo-randomness property from \Eval. In our construction in \S\ref{sec:pederson_vrf},  \rVRF.\KeyGen and \rVRF.\Eval resemble EC VRF like \cite{nsec5,VXEd25519,draft-irtf-cfrg-vrf-10}.

% TODO: Should this text be moved elsewhere?
% and prove it corresponds to $\rVRF.\Eval$ for some plausible signer.

% As an instructive but insecure over simplification, 
Different than VRF, a ring VRF scheme has  the following algorithms operate directly upon
 set of public keys \ring:
\begin{itemize}
\item $\rVRF.\rSign : (\sk,\ring,\msg) \mapsto \sigma$ \,
    returns a ring VRF signature $\sigma$ for an input \msg.
\item $\rVRF.\rVerify : (\ring,\msg,\sigma) \mapsto \Out \, \lor \perp$ \,
    returns either an output $\Out$ or else failure $\perp$.
\end{itemize}

Ring VRFs differ from VRFs in that they do not expose a specific signer,
and instead prove the signer's key lies in  \ring,
much like how ring signatures differ from signatures.
Ring VRFs differ from ring signatures in that the verification process of Ring VRFs outputs the evaluation output \Out of the signer if the signature is verified with $ \ring $. So  the ring signature  actually proves that $ \Out $ is the evaluation output of the signer. 




After success verification, our verifier should be convinced that $\pk \in \ring$, that
$\Out = \rVRF.\Eval(\sk,\msg)$ for some $(\sk,\pk) \leftarrow \rVRF.\KeyGen$. We demand anonymity meaning that the verifier learns nothing about the signer except that the signer's evaluation value of the signed message $ \msg $ is $ \Out $ and the signer's public key is in $ \ring $.

In other words, this simplified ring VRF could be instantiated by making
\rVRF.\Eval a pseudo-random (hash) function, and using a NIZK for a relation
\vspace{-3mm}
$$ \rel_{\mathsf{rvrf}} = \Setst{ (\Out, \msg, \ring);(\sk,\pk)}{
		\begin{aligned}
			& (\pk,\sk) \leftarrow \rVRF.\KeyGen,
			& \pk \in \ring \\
			& \Out = \rVRF.\Eval(\sk,\msg)
		\end{aligned}
} $$


% TODO:  \PRF vs \rVRF.\Eval here??
% Although convenient for security arguments, % formalization

The zero-knowledge property of the NIZK ensures that our verifier learns nothing about the specific
signer, except that their key is in the ring and maps $\msg$ to $\Out$.
Importantly, pseudo-randomness also says that \Out is an identity
for the specific signer, but only within the context of \msg.

% \smallskip

Aside from proving an evaluation using \rVRF.\Eval, 
we always need \rVRF.\Sign and \rVRF.\Verify to sign some associated data \aux,
as otherwise the ring VRF signature become unmoored and permits replay attacks.
%
As an example, our identity protocol below in \S\ref{sec:app_identity}
yields the same ring VRF outputs each time the same user logs into the
same site, which suffers replay attacks unless \aux binds the
ring VRF signature to the TLS session.

\eprint{Indeed, regular (non-anonymous) VRF uses always encounter similar tension
with VRF inputs \msg being smaller than full message bodies $(\msg,\aux)$.
As an example, Praos \cite{praos} binds their VRF public key together
with a second public key for another (forward secure) signature scheme,
with which they sign their \aux, the block itself.
%
An EC VRF should expose an \aux parameter which it hashes when computing
its challenge hashes.  Aside from saving redundant signatures, exposing
\aux avoids user key handling mistakes that create replay attacks.}{}

Ring VRFs cannot so easily be combined with another signatures, which
makes \aux essential,%
\eprint{\footnote{If ring VRFs authorized creating blocks in an anonymous Praos blockchain then \aux must include the block being created, or else others could steal their block production turn.}}{}
but thankfully our ring VRF construction in in \S\ref{sec:pederson_vrf} expose \aux exactly like EC VRFs should do .%
\eprint{\footnote{We suppress multiple input-output pairs until \S\ref{subsec:multi_io} below, but they work like in \cite{PrivacyPass} too.}}{}

% \smallskip

If one used the $\rVRF$ interface described above, then one needs time
$O(|\ring|)$ in \rVRF.\rSign and \rVRF.\rVerify merely to read their \ring
argument, which severely limits applications.
Instead, ring signatures run asymptotically faster by replacing the \ring
argument with a set commitment to \ring, roughly like what ZCash does \cite{zcash_protocol}. Therefore, we introduce the following algorithms for $ \rVRF $.
\begin{itemize}
% \item $\rVRF.\CheckRing : \ring \mapsto \comring$ takes a set \ring of public keys and returns a public key set commitment \comring.
\item $\rVRF.\CommitRing : (\ring,\pk) \mapsto (\comring,\openring)$ \,
    returns a commitment for a set \ring of public keys, and
    optionally the opening \openring if $\pk \in \ring$ as well.
\item $\rVRF.\OpenRing : (\comring,\openring) \mapsto \pk \, \lor \perp$ \,
    returns a public key \pk, provided \openring correctly opens
    the ring commitment \comring, or failure $\perp$ otherwise.
\end{itemize}

We thus replace the membership condition $\pk \in \ring$ in the above
relation and NIZK by the opening condition
$ \pk = \rVRF.\OpenRing(\comring,\openring) \textrm{\ for some known \ } \openring \mathperiod $
% $\pk = \OpenRing(\comring,\openring)$.
%
% $$ \pi_0 = \NIZK \Setst{ \Out, \msg, \comring }{
%     \begin{aligned}
%         \exists (\pk,\sk) &\leftarrow \KeyGen,  \quad
%           \Out = \PRF(\sk,\msg)  \\
%         \exists \openring \textrm{\ s.t.\ }
%           \pk &= \OpenRing(\comring,\openring)  \\      
%     \end{aligned}
% } $$

% \smallskip

\eprint{Addressing these concerns, our notion should really be named 
 \emph{ring verifiable random function with additional data}
and its basic methods look like
\begin{itemize}
\item $\rVRF.\rSign : (\sk,\openring,\msg,\aux) \mapsto \sigma$, \quad and
\item $\rVRF.\rVerify : (\comring,\msg,\aux,\sigma) \mapsto \Out \,\, \lor \perp$.
\end{itemize}}{}


Although an asymptotic improvement, our opening \rVRF.\OpenRing based condition invariably
still winds up being computationally expensive to prove inside a zkSNARK.
We solve this obstacle in \S\ref{sec:rvrf_cont}  by introducing
{\em zero-knowledge continuations}, a new zkSNARK technique built from
rerandomizable Groth16s \cite{Groth16} and designed for SNARK composition and reuse.

As a step towards this, we split the relation $ \rel_{\mathsf{rvrf}} $ into a relation
$ \rel_{eval} $ for \rVRF evaluation and a relation $ \Rring $, which enforces our
computationally expensive condition $\pk = \rVRF.\OpenRing(\comring,\openring)$.
We want to reuse the proof for $ \Rring $ across multiple \rVRF signatures, so anonymity
requires we rerandomize a Groth16 SNARK for $ \Rring $
ala \cite[Theorem 3, Appendix C, pp. 31]{RandomizationGroth16}.
%
Yet, we must connect together the NIZKs for the two languages  $ \rel_{eval} $ and $ \Rring  $ that we define below informally. We do this by passing \pk from $ \Rring  $ to $ \rel_{eval} $, which
demands some hiding commitment \compk to \pk.

%
\def\tmpAA{\Out = \rVRF.\Eval(\sk,\msg)}%
\def\tmpBB{\textrm{\compk commits to\ \sk}}%
$$ \rel_{eval} = \Setst{ (\Out, \msg, \aux, \compk); \sk}{
	\eprint{
		\tmpAA, \, \tmpBB
	}{
		\begin{aligned}
			&\tmpAA, \\
			&\tmpBB \\
		\end{aligned}
	}
} $$

\def\tmpAA{\textrm{\compk commits to $ \sk $ with public key\ }}%
\def\tmpBB{\rVRF.\OpenRing(\comring,\openring)}%
$$ \Rring = \Setst{ (\compk, \comring);(\sk,\pk) }{
	\eprint{
		\tmpAA \pk = \tmpBB
	}{
		\begin{aligned}
			&\tmpAA \\
			&\, \pk = \tmpBB \\
		\end{aligned}
	}
} $$

%TODO: WE SHOULD EXPLAIN IT BETTER AND CHANGE THE LANGUAGE TO A RELATION
%We discovered the SNARK for the language \Lring becomes incredibly efficient for the prover if one specializes
%the original Groth16 SNARK construction:  An inner original Groth16 SNARK for $\Lring^\inner$
%handles the secret key \sk directly via its public inputs, but
%\sk and even \pk remain secret by transforming the trusted setup to have
%a rerandomizable Pedersen commitment \compk outside this Groth16 SNARK.
%$$ \Lring^\inner = \Setst{ \sk, \comring}{
%    \eprint{
%    (\pk,\sk) \leftarrow \rVRF.\KeyGen, \, % \textrm{\,and }
%    \pk = \rVRF.\OpenRing(\comring,\openring) 
%    }{
%    \begin{aligned}
%        &(\pk,\sk) \leftarrow \rVRF.\KeyGen, \\
%        % \exists \openring \textrm{\ s.t.\ }
%        &\pk = \rVRF.\OpenRing(\comring,\openring)  \\      
%    \end{aligned}
%    }
%} $$
%
%Our zero-knowledge continuation in \S\ref{sec:rvrf_cont} rerandomizes
%$\compk = \pk + b \, K$ without reproving the Groth16 SNARK for $\Lring^\inner$.
%For this, the secret key \sk must be a public input of $\Lring^\inner$, and
%the Groth16 trusted setup must be expanded by a secret multiple of
% the otherwise independent point $K$.
%
In \S\ref{sec:pederson_vrf}, we introduce an extremely efficient NIZK
for $ \rel_{eval} $, which also provides an essential proof-of-knowledge for \compk.


\endinput


% We define ring VRFs in \S\ref{sec:rvrf_games} and \S\ref{sec:rvrf_uc_fun} below, but
Ring VRFs are firstly ring signatures broadly interpreted, in that they
prove an involved public key lies inside some commitment \comring to
the plausible signer set, known as the ring.
Anyone could compute \comring from this set of public keys.
%
At the same time, ring VRFs prove correct output of a PRF keyed by
the signer's actual secret key, and evaluated on a supplied message \msg,
which then links ring VRF signatures on the same \msg.

\smallskip
