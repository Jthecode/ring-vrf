\begin{figure}
	\scriptsize 
	\begin{tcolorbox}
		{  $ \fgvrf $ runs two PPT algorithms $ \gen_W$ and $\gen_{sign} $ during the execution.
			
			\begin{description}
				
				\item[Key Generation.] upon receiving a message $(\msg{keygen}, \sid)$ from a party $\user_i$, send $(\msg{keygen}, \sid, \user_i)$ to the simulator $\simulator$.
				Upon receiving a message $(\msg{verificationkey}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ has not been recorded before for $ \sid $; then, store in the table $\vklist$, under $\user_i$, the value $\pkrvrf$.
				Return $(\msg{verificationkey}, \sid, \pkrvrf)$ to $ \user_i$.
				
				\item[Malicious Key Generation.] upon receiving a message $(\msg{keygen}, \sid, \pkrvrf)$ from $\simulator$, verify that $\pkrvrf$ was not yet recorded, and if so record in the table $\vklist$ the value $\pkrvrf$ under $\simulator$. Else, ignore the message.
				
				%\item[Honest Ring VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that 
				%$\pkrvrf_i \in \pkring$ 
				%and  
				%there exists $ \pkrvrf_i $ in $\vklist $ associated with $ \user_i $. If that was not the case, just ignore the request.
				%If there exists no $ W $ such that $ \anonymouskeymap[W] = (m, \pkring, \pkrvrf_i) $, let $ W \sample \bin^\secpar $ and  $y \sample \bin^{\ell_\rvrf}$. Then, set $ \evaluationslist[m, W] = y$ and $ \anonymouskeymap[W] = (m, \pkring,\pkrvrf_i) $.
				%Return $(\msg{evaluated}, \sid, \pkring, m, W, y)$ to $ \user_i $.
				%The functionality does not check whether the evaluater's public key is in the ring because here we consider m, \pkring as an input of the evaluation which is evaluated by a party who is not neccesarily in the ring. 
				\item [Corruption:]  
				upon receiving $ (\msg{corrupt}, \sid, \user_i) $ from $ \simulator $, remove $ \pkrvrf_i $ from $ \vklist[\user_i] $ and store $ \pkrvrf_i $ to $ \vklist $ under $ \sim $. Return $ (\msg{corrupted}, \sid,\user_i) $.
				\item[Malicious Ring VRF Evaluation.] upon receiving a message $(\msg{eval}, \sid, \pkrvrf_i, W, m)$ from $\sim$, if $ \pkrvrf_i $ is recorded under an honest party's identity or if there exists $ W'\neq W $ where $ \anonymouskeymap[m,W'] = \pkrvrf_i $, ignore the request.
				Otherwise, record in the table $\vklist$ the value $\pkrvrf_i$ under $\simulator$ if $ \pkrvrf_i $ is not in $ \vklist $. If  $\anonymouskeymap[m,W]  $ is not defined before, set $ \anonymouskeymap[m,W] = \pkrvrf_i $ and let   $y \sample \bin^{\ell_\rvrf}$ and set $ \evaluationslist[m, W] = y$.
				Then, set $ \evaluationslist[m, W] = y$, $ \anonymouskeymap[m,W] = \pkrvrf_i $ obtain $ y =  \evaluationslist[m, W]$. Otherwise, obtain $ y = \evaluationslist[m, W'] $.
				Return $(\msg{evaluated}, \sid,  m, \pkrvrf_i,W, y)$ to $ \user_i $.
				
				
				%upon receiving a message $(\msg{eval}, \sid, \pkrvrf_i, W, m)$ from $\sim$, if $ \pkrvrf_i $ is recorded under an honest party's identity or if there exists $ \anonymouskeymap[m, \pkrvrf_i] \neq W $ or if there exists a record for a key $ \pkrvrf \neq \pkrvrf_{i}$ such that $ \anonymouskeymap[m, \pkrvrf] = W $, ignore the request. Otherwise, record in the table $\vklist$ the value $\pkrvrf_i$ under $\simulator$ if $ \pkrvrf_i $ is not in $ \vklist $. If $ \anonymouskeymap[m,\pkrvrf_i]  $ is not defined, set $ \anonymouskeymap[m,\pkrvrf_i] = W $ and let   $y \sample \bin^{\ell_\rvrf}$ and set $ \evaluationslist[m, W] = y$.
				%Return $(\msg{evaluated}, \sid,  m, W, \evaluationslist[m, W])$ to $ \user_i $.
				
				
				
				\item[Honest Ring VRF Signature and Evaluation.] upon receiving a message $(\msg{sign}, \sid, \pkring, \pkrvrf_i, m)$ from $\user_i$, verify that $\pkrvrf_i \in \pkring$ and that there exists a public key $\pkrvrf_i$ associated to $\user_i$ in the table $ \vklist $. If that wasn't the case, just ignore the request. 	
				If there exists no $ W' $ such that $ \anonymouskeymap[m,W'] =  \pkrvrf_i $, let $ W \sample \{0,1\}^{w(\secpar)}$ and let $y \sample \bin^{\ell_\rvrf}$. If there exists $ W $ where $ \anonymouskeymap[m,W] $ is defined, then abort. Otherwise, set $ \anonymouskeymap[m,W] = \pkrvrf_i $ and set $ \evaluationslist[m, W] = y$.
				Obtain $ W, y $ where $ \anonymouskeymap[m,W] =\pkrvrf_i $ and $ \evaluationslist[m, W] = y$  and run  $ \gen_{sign}(\pkring, W) \rightarrow \sigma $. Verify that $ [m, W,\pkring, \sigma, 0] $ is not recorded. If it is recorded, abort. Otherwise, record $ [m, W, \pkring,\sigma, 1] $. Return $(\msg{signature}, \sid, \pkring,W,m, y, \sigma)$ to $\user_i$.
			
			%\item[Malicious VRF evaluation.] upon receiving a message $(\msg{evalprove}, \sid, \pkring, m)$ from $\simulator$, check that $\vklist$ has a public key associated to $\simulator$. If not, ignore the request. If $\evaluationslist[\pkring, m][\simulator]$ is not set, sample $y \sample \bin^{\ell(\secpar)}$ and set $\evaluationslist[\pkring, m][\simulator] \defeq y$ (and $\signaturelist[\pkring,m]$ to $\emptyset$). If $\signaturelist[\pkring, m]$ contains a proof (i.e., if $\signaturelist[\pkring, m]$ is not empty), return $(\msg{evaluated}, \sid, y)$ to $\simulator$. Else, ignore the request.
			
			%\item[Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring, m, y, \sigma)$, from any party forward the message to the simulator. If there exists a $\pkrvrf_i$ among the values of \texttt{verification\_keys}, and there exists $\sigma \in \signaturelist[\pkring, m]$, set $b = 1$. Else, set $b =0$. Finally, output $(\msg{verified}, \sid, \pkring, m, y, \sigma, b)$.
			\item [Malicious Requests of  Signatures and Outputs.] upon receiving a message $ (\msg{request}, \sid, \pkring, W, m) $ from $ \simulator $, obtain all existing valid signatures $ \sigma $ such that $ [m,W,\pkring,\sigma, 1] $ is recorded and add them in a list $ \lst_{\sigma} $. If $ \lst_{\sigma}  $ is not empty, obtain $ \out[m,W] $ and set $ y = \out[m,W]  $. Otherwise, set $ y = \perp $. Return $ (\msg{requests}, \sid, \pkring, W,m, \lst_{\sigma},y)  $ to $ \simulator $.
			\item[Ring VRF Verification.] upon receiving a message $(\msg{verify}, \sid, \pkring,W, m, \sigma)$ from a party, do the following: 
			\begin{enumerate}[label={{Cond.-} }{{\arabic*}}, start = 1]
				\item If there exits a record $ [m,W,\pkring,\sigma, b'] $, set $ b = b' $. (This condition guarantees the completeness and consistency.)
				%					\item Else if $ \pkrvrf  $ is an honest verification key where $ \anonymouskeymap[W] = (.,., \pkrvrf) $ and there exists no record $ [m, \pkring, W, \sigma', 1] $ for any $ \sigma' $, then let $ b= 0  $.
				%					(This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \pkring $, then the verification fails.)\label{cond:forgery}
				
				%\item Else if there exists a record  such as $ [m,W,\pkring,\sigma, b'] $, set $ b = b' $. (This condition guarantees consistency meaning that all identical verification requests will output the same $ b $) 
				\label{cond:consistency}
				\item Else if $ \anonymouskeymap[m,W]  $ is an honest verification key and  there exists a record $ [m, W,\pkring, \sigma', 1] $ for any $ \sigma' $, then let $ b=1 $ and record $ [m, W,\pkring,\sigma, 1] $. (This condition guarantees that if $ m $ is signed by an honest party for the ring $ \pkring $ at some point, then the signature is $ \sigma' \neq \sigma $ which is generated by the adversary is valid) \label{cond:differentsignature}
				
				\item \label{cond:malicioussignature}Else relay the message $(\msg{verify}, \sid, \pkring,W, m, \sigma)$ to $ \simulator $ and receive back the message $(\msg{verified}, \sid, \pkring,W, m, \sigma, b_{\simulator}, \pkrvrf_\simulator)$.  Then check the following:
				\begin{enumerate}
					\item If $ W \notin \anonymouskeylist $ and $ |\anonymouskeylist[m, \pkring]| > |\pkring_{mal}| $ where $ \pkring_{mal} $ is a set of malicious keys in $ \pkring $, set $ b = 0 $.
					(This condition guarantees  uniqueness meaning that the number of verifying outputs that $ \sim $ can generate for $ m, \pkring $ is at most the  number of malicious keys in $ \pkring $.)\label{cond:uniqueness}.
					
					\item Else if $ \pkrvrf_\simulator $ is an honest verification key, set $ b = 0 $. (This condition guarantees unforgeability meaning that if an honest party never signs a message $ m $ for a ring $ \pkring $)\label{cond:forgery}
					%\item \label{cond:forgerymalicious}Else if there exists $ \anonymouskeymap[W] = (m', \pkring',.)  $ where $ (m', \pkring') \neq (m, \pkring) $ or $ \counter[m, \pkring] > |\pkring_m| $ where $ \pkring_m $ is a set of keys in $ \pkring $ which are not honest or $ b_{\simulator} = 0 $ or $ \pkrvrf_\simulator $ belongs to an honest party, set $ b = 0 $ and record $ [m, \pkring,W,\sigma, 0] $. (This condition guarantees that if $ W $ is an anonymous key of a different message and ring or the number of anonymous keys of malicious parties in $ \pkring $ is more than their number or     $ \simulator $ does not verify $ \sigma $, then the verification fails.)
					
					\item Else if there exists $ W' \neq W $ where  $ \anonymouskeymap[m,W'] = \pkrvrf_\simulator $, set $ b = 0 $. \label{cond:differentWforsamepk}
					\item Else set $ b = b_\sim$. \label{cond:simulatorbit}
				\end{enumerate}		
				
				
			\end{enumerate}
			In the end,  record $ [m,W,\pkring,\sigma, 0] $ if it is not stored. If $ b = 0 $, let $ \out = \perp $. Otherwise,   do the following:
			\begin{itemize}
				\item if $ W \notin \anonymouskeylist[m,\pkring] $, add $ W $ to $ \anonymouskeylist[m,\pkring]  $.
				\item if $ \pkrvrf_\simulator $ is not recorded, record it in $ \vklist $ under $ \simulator $.
				\item if $ \evaluationslist[m,W] $ is not defined, set $ \evaluationslist[m, W]\sample \bin^{\ell_\rvrf}$, $ \anonymouskeymap[m,W]  = \pkrvrf_\simulator$.  Set $ \out = \evaluationslist[m, W]$.
				\item otherwise, set $ \out = \evaluationslist[m, W]$. 	
			\end{itemize}
			Finally, output $(\msg{verified}, \sid, \pkring,W, m, \sigma, \out, b)$ to the party.
			
		\end{description}
		
		
	}
\end{tcolorbox}
\caption{Functionality $\fgvrf$.\label{f:gvrf}}
\end{figure}



