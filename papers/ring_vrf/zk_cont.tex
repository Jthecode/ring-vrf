\section{Zero-knowledge Continuations}
\label{sec:rvrf_cont}

NOT READY YET

\noindent In the following, we describe a NIZK for a relation $\rel$ where
$$\rel = \{(\bary, \barz; \barx, \baromega, \baromegap):  (\bary, \barx; \baromega) \in \relone, (\barz, \barx; \baromegap) \in \reltwo \},$$
and $\relone$, $\reltwo$ are some NP relations. Our NIZK is designed to efficiently re-prove membership for relation $\relone$
via a new technique which we call \emph{zero-knowledge continuation}. In practice, using a NIZK that is a zero-knowledge continuation 
ensures one essentially needs to create only once an otherwise expensive proof for $\relone$ which can later be 
re-used multiple times (just after inexpensive re-randomisations) while preserving knowledge soundness and zero-knowledge. 
Below, we formally define zero-knowledge continuation. In section~\ref{sec:rvrf_groth16} we instantiate it via a \emph{special(ized) 
Groth16} or \SpecialG, and finally, in section~\ref{subsec:rvrf_faster} we use it to build a ring VRF with fast amortised prover time. \\

\noindent In addition, the anonymity property of our ring VRF demands we not only finalise multiple times a component of the zero-knowledge 
continuation and but also each time the result remains unlinkable to previous finalisations, meaning our ring VRF stays zero-knowledge 
even with a continuation component being reused. We formalise such a more general zero-knowledge property in 
section~\ref{sec:rvrf_groth16} and give an instantiation of our NIZK fulfilling such a property in section~\ref{subsec:rvrf_faster}. 
%Moreover, the anonymity property of a ring VRF demands we finalise the amortized ``continuation'' multiple
%times, with each time being unlinkable to the others, meaning our rVRF
%stays zero-knowledge even with the continuation being reused.


%\begin{definition}[ZK Continuations] A zero-knowledge continuation $\SpecialG_\rel$ consists of four algorithms 
%($\SpecialG_\rel.\Preprove$, $\SpecialG_\rel.\Reprove$, $\ldots$, $\SpecialG_\rel.\Verify$) such that:
%\begin{itemize}
%\item $\SpecialG_\rel.\Preprove : (\bar{y}, \bar{x}; \bar{\omega}) \mapsto (X,\pi)$ \,
%constructs a commitment $X$ and a proof $\pi$ for relation $\rel$ from a vector 
%of inputs $\bar{y}$ (called \em{transparent}), a vector of inputs $\bar{x}$ (called \em{opaque}), and witnesses $\bar{\omega}$.
%\item $\SpecialG_\rel.\Reprove : (X,\pi) \mapsto ((X',\pi'); b)$ \,
%finalises the commitment $X'$ and proof $\pi'$ and returns an opening $b$ for the commitment. 
%\item $\SpecialG_\rel.\Verify(\bar{y}; (X',\pi') )$ \, 
%verifies the 
%\end{itemize}
%%TO DO: add an algorithm to the $\SpecialG_\rel$ such that: Our \Verify needs a separate proof-of-knowledge for $X'$, 
%%the production of which requires knowledge of $\bar{x}$, and occurs in parallel to \Reprove.

%We define (white-box) knowledge soundness for zero-knowledge continuations
%exactly like for zero-knowledge proofs, but with the composition 
%$\Prove : (\bar{y}, \bar{x}; \bar{\omega}) \mapsto \Reprove(\Preprove(\bar{y}, \bar{x}; \bar{\omega}))[0]$
%as well as this additional proof-of-knowledge.
%Zero-knowledge however should hold even if \Reprove gets invoked multiple
%times upon the same \Preprove results, again even with the additional proof-of-knowledge.
%\end{definition} 

\begin{definition}[ZK Continuations]
\label{def:zk_cont}
 A zero-knowledge continuation $\ZKCont$ for a relation $\relone$ with 
input $(\bary, \barx)$ and witness $\baromega$ is a tuple of efficient algorithms 
($\ZKCont.\Setup$, $\ZKCont.\Gen$, $\ZKCont.\Preprove$, $\ZKCont.\Reprove$, $\ZKCont.\VerifyCom$, $\ZKCont.\Verify$, $\ZKCont.\Sim$) 
such that for implicit security parameter $\lambda$,
\begin{itemize}

\item $\ZKCont.\Setup: (1^{\lambda}) \mapsto (\crs, \tw)$ a setup algorithm that on input the security parameter 
outputs a common reference string $\crs$ and a trapdoor $\tw$,

\item $\ZKCont.\Gen: (\crs, \relone) \mapsto (\pp, \crspk, \crsvk)$ \, 
outputs a list $\pp$ of public parameters and a pair of proving key $\crspk$ and verification key $\crsvk$, 

\item $\ZKCont.\Preprove: (\crspk, \bar{y}, \bar{x}, \bar{\omega}, \relone) \mapsto (X, \pi, b)$ \,
constructs commitment $X$ from a vector of inputs $\bar{x}$ (called \emph{opaque}) and 
constructs proof $\pi$ from vector of inputs 
$\bar{y}$ (called \emph{transparent}), from $\bar{x}$ and vector of witnesses $\bar{\omega}$, and 
also outputs $b$ as the opening for $X$,

\item $\ZKCont.\Reprove: (\crspk, X, \pi, b, \relone) \mapsto (X', \pi', b')$ \,
finalises commitment $X'$ and proof $\pi'$ and returns an opening $b'$ for the commitment, 

\item $\ZKCont.\VerifyCom: (\pp, X, \barx, b) \mapsto 0/1$ \, 
verifies that indeed $X$ is a commitment to $\barx$ with opening (e.g., randomness) $b$ and 
outputs 1 if indeed that is the case and 0 otherwise,
 
\item $\ZKCont.\Verify: (\crsvk, \bar{y}, X', \pi', \relone) \mapsto 0/1$ \, outputs $1$ in case it accepts and $0$ otherwise,

\item $\ZKCont.\Sim: (\tw, \bary, \relone) \mapsto (\pi', X')$ takes as input a simulation trapdoor $\tw$ and statement $(\bary, \barx)$ and returns 
arguments $\pi'$ and $X'$,
\end{itemize}
and satisfies perfect completeness for $\Preprove$ and for $\Reprove$,  knowledge soundness and zero-knowledge as defined below:\\
%TO DO: Re-write this: We define (white-box) knowledge soundness for zero-knowledge continuations
%exactly like for zero-knowledge proofs, but with the composition 
%$\Prove : (\bar{y}, \bar{x}; \bar{\omega}) \mapsto \Reprove(\Preprove(\bar{y}, \bar{x}; \bar{\omega}))[0]$
%as well as this additional proof-of-knowledge.
%Zero-knowledge however should hold even if \Reprove gets invoked multiple
%times upon the same \Preprove results,
%again even with the additional proof-of-knowledge.
\noindent \textbf{Perfect Completeness for $\Preprove$} For every $(\bary, \barx; \baromega) \in \relone$ it holds:
\begin{align*}
\mathit{Pr} (& \ZKCont.\Verify(\crsvk, \bar{y}, X, \pi, \relone) = 1 \ \wedge \ \ZKCont.\VerifyCom (\pp, X, \barx, b) = 1\  | \ \\ 
                   & (\crs, \pp) \leftarrow \ZKCont.\Setup (1^{\lambda}), (\crspk, \crsvk) \leftarrow \ZKCont.\Gen(\crs, \relone), \\ 
                   & (X, \pi, b) \leftarrow \ZKCont.\Preprove(\crspk, \bar{y}, \bar{x}, \bar{\omega}, \relone)) = 1
\end{align*}

\noindent \textbf{Perfect Completeness for $\Reprove$} For every efficient adversary $A$ it holds: 
\begin{align*}
\mathit{Pr} (& (\ZKCont.\Verify(\crsvk, \bar{y}, X, \pi, \relone) = 1  = >  \ZKCont.\Verify(\crsvk, \bar{y}, X', \pi', \relone) = 1)  \ \wedge \  \\
                   & \wedge \ (\ZKCont.\VerifyCom (\pp, X, \barx, b) = 1 => \ZKCont.\VerifyCom (\pp, X', \barx, b') = 1) \ | \\
                   & (\crs, \pp) \leftarrow \ZKCont.\Setup (1^{\lambda}), (\crspk, \crsvk) \leftarrow \ZKCont.\Gen(\crs, \relone), \\ 
                   & (\bary, \barx, X, \pi, b) \leftarrow A(\crs,\pp, \relone), (X', \pi', b') \leftarrow \ZKCont.\Reprove(\crspk, X, \pi, b, \relone)) = 1
\end{align*}
\noindent \textbf{Knowledge Soundness} For every benign auxiliary input $z$ (see~\cite{bening_auxiliary}), 
for every non-uniform efficient adversary $A$, there exists an efficient non-uniform extractor $E$ such that 
\begin{align*}
\mathit{Pr} (& (\ZKCont.\Verify(\crsvk, \bar{y}, X, \pi, \relone) = 1) \ \wedge \ (\ZKCont.\VerifyCom(\pp, X, \bar{x}, b) = 1) \ \wedge\ \\
                   & \wedge \ ( (\bary, \barx; \baromega) \notin \relone) \ | \ (\crs, \pp) \leftarrow \ZKCont.\Setup (1^{\lambda}), 
                   (\bary, \barx, X, \pi, b; \baromega ) \leftarrow A || E (\crs, z, \relone)) = \negl (\lambda),
\end{align*}
\noindent %where $\ZKCont.\Preprove_{|X}(\crspk, \bar{y}, \bar{x}, \bar{\omega}, \relone; b)$ means running the part of algorithm 
%$\ZKCont.\Preprove$ that computes and outputs $X$ with its regular inputs and using $b$ when randomness is required; 
where by $(\mathit{output_{A}};\mathit{output_{B}}) \leftarrow A || B(\mathit{input})$ we denote algorithms that run on the same 
$\mathit{input}$, and, moreover $B$ has access to the random coins of $A$. \\

\noindent \textbf{Perfect Zero-knowledge w.r.t. $\relone$} For all $\lambda \in \mathbb{N}$, for every benign auxiliary input $z$, 
for all  $(\bary, \barx; \baromega) \in \relone$, for all $X$, for all $\pi$, for all $b$, for every adversary $A$ it holds:
\begin{align*}
\mathit{Pr}(& A(\crs, z, \pi', X', \relone) = 1 \ | \ (\crs, \pp) \leftarrow \ZKCont.\Setup (1^{\lambda}), \\
                  & (\crspk, \crsvk) \leftarrow \ZKCont.\Gen(\crs, \relone), (\pi', X', \_) \leftarrow \ZKCont.\Reprove (\crspk, X, \pi, b, \relone), \\
                  &  \ZKCont.\Verify(\crsvk, \bary, X, \pi, \relone) = 1) =  \\
= \mathit{Pr}(& A(\crs, z, \pi', X', \relone) = 1 \ | \ (\crs, \pp) \leftarrow \ZKCont.\Setup (1^{\lambda}), \\ 
                     & (\crspk, \crsvk) \leftarrow \ZKCont.\Gen(\crs, \relone), (\pi', X') \leftarrow \ZKCont.\Sim(\tw, \bary, \relone) \\ 
                     &  \ZKCont.\Verify(\crsvk, \bary, X, \pi, \relone) = 1)
\end{align*}
 
\end{definition} 

% $$ \Lring = \Setst{ \compk, \comring }{
%  \exists \openpk,\openring \textrm{\ s.t.\ } 
%  \genfrac{}{}{0pt}{}{\PedVRF.\OpenKey(\compk,\openpk) \quad}{\,\, = \rVRF.\OpenRing(\comring,\openring)}
% } \mathperiod $$

% \smallskip
\subsection{Specialised Groth16}
\label{sec:rvrf_groth16}

Below we instantiate our zero-knowledge continuation notion with a scheme based on Groth16~\cite{Groth16} SNARK;
hence, we call our instantiation \emph{specialised Groth16} or \emph{$\mathsf{SpecialG}$}. In order to do that, we need a 
reminder of the definition of Quadratic Arithmetic Program (QAP)~\cite{LegoSNARK}, ~\cite{GGPR13}.

\begin{definition}[QAP] 
\label{def:QAP}
A Quadratic Arithmetic Program (QAP) $\cQ = (\cA, \cB, \cC, t(X))$ of size $m$ 
and degree $d$ over a finite field $\F_q$ is defined by three sets of polynomials $\cA = \{a_i(X)\}_{i=0}^m$, 
$\cB = \{b_i(X)\}_{i=0}^m$, $\cC = \{c_i(X)\}_{i=0}^m$ of degree less than $d-1$ and a target degree $d$ polynomial $t(X)$. Given 
$\cQ$ we define $\relRQ$ as the set of pairs $((\bary, \barx); \baromega) \in \F_q^{l} \times \F_q^{n-l} \times \F_q^{m-n}$ for which it 
holds that there exist a polynomial $h(X)$ of degree at most $d-2$ such that:
$$(\sum_{k=0}^m v_k \cdot a_k(X)) \cdot (\sum_{k=0}^m v_k \cdot b_k(X)) = (\sum_{k=0}^m v_k \cdot c_k(X)) + h(X)t(X) \ \ (\ast)$$ 
where $\barv = (v_0, \ldots, v_m) = (1, x_1, \ldots, x_n, w_1, \ldots w_{m-n})$ and $\bary = (x_1, \ldots, x_l)$ and 
$\barx = (x_{l+1}, \ldots, x_n)$ and $\baromega = (w_1, \ldots, w_{m-n})$. 
\end{definition}

\noindent Given notation provided in section~\ref{sec:background}, we introduce
%Let $\mathbb{F}_q$ be a prime field, 
%let $G_1$, $G_2$, $G_T$ be as defined in section~\ref{??}, let $e$, $g$, $h$ be defined as $\ldots$. Let $t(X)$ and
%$\{u_i(X),v_i(X),w_i(X)\}_{i=0}^m$ be polynomials in $\F_q[X]$, let $\ldots$ be $\ldots$ such that there exists $h(X) \in \F_q[X]$ with
% $$ \sum_{i=0}^m a_iu_i(X) \cdot  \sum_{i=0}^m a_iv_i(X)  = \sum_{i=0}^m a_iw_i(X) + h(X)t(X)  \ (\ast)$$
%Then let $\relone = \{ (;) \ | \ (;)  (\ast) \}$

\begin{definition}[Specialised Groth16 ($\SpecialG$)]
\label{insta:sg16} 
Specialised Groth16 for relation $\relRQ$ is the following instantiation of the zero-knowledge continuation notion from Definition~\ref{def:zk_cont}:
\begin{itemize}
\item $\SpecialG.\Setup: (1^{\lambda}) \mapsto (\crs, \tw)$. \\ 
\noindent Let $\alpha, \beta, \gamma, \delta, \tau, \eta  \xleftarrow{\$} \F_q^{*}$. Let $\tw = (\alpha, \beta, \gamma, \delta, \tau, \eta)$. \\ 
Let $\crs = ([\barsig_1]_1, [\barsig_2]_2)$ where 
\begin{align*}
\barsig_1 = (&\alpha, \beta, \delta, \{\tau_i\}_{i=0}^{d-1}, \left\{\frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma}\right\}_{i=1}^n,  
\frac{\eta}{\gamma}, \\ 
&\left\{\frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\delta} \right\}_{i=n+1}^m, \left\{\frac{1}{\delta}\sigma^it(\sigma) \right\}_{i=0}^{d-2}, 
\frac{\eta}{\delta}), \\
\barsig_2 = (&\beta, \gamma, \delta, \{\tau^i\}_{i=0}^{d-1}). 
\end{align*} 

\noindent Moreover, for simplicity and later use, we call $\Kgamma = \left[\frac{\eta}{\gamma}\right]_1$  and $\Kdelta = \left[ \frac{\eta}{\delta}\right] _1$.

\item $\SpecialG.\Gen: (\crs, \relRQ) \mapsto (\pp, \crspk, \crsvk)$ where \\
$\crspk = \left([\barsig_1]_1, [\beta]_2, [\delta]_2, \left\{[\tau^i]_2\right\}_{i=0}^{d-1}\right)$ and \\ 
$\crsvk = \left([\alpha]_1, \left\{ \left[ \frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma} \right]_1 \right\}_{i=1}^{l}, 
[\beta]_2, [\gamma]_2, [\delta]_2\right)$ and \\ 
$\pp = \left( \left \{ \left[ \frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma} \right]_1 \right \}_{i=l+1}^{n}, \left[ \frac{\eta}{\gamma} \right]_1 \right)$.


\item $\SpecialG.\Preprove: (\crspk, \bar{y}, \bar{x}, \bar{\omega}, \relRQ) \mapsto (X, \pi, b)$ such that \\
\begin{align*}
&b = 0; r, s\xleftarrow{\$} \F_p; X = \sum_{i=l+1}^{n} v_i\left[ \frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma} \right]_1; \pi = ([A]_1, [B]_2, [C]_1); \\
&A = \alpha + \sum_{i=0}^{m} v_i \cdot a_i(\tau) + r\delta; B = \beta + \sum_{i=0}^{m} v_i \cdot b_i(\tau) + s\delta; \\ 
&C = \frac{\sum_{i=n+1}^{m} v_i \beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau) + h(\tau)t(\tau)}{\delta}   + As + Br - rs\delta, 
\end{align*}
and where $\bary = (x_1, \ldots, x_l)$, $\barx = (x_{l+1}, \ldots, x_n)$, $\baromega = (w_1, \ldots, w_{m-n})$, \\
$\barv = (1, x_1, \ldots, x_n, w_1, \ldots, w_{m-n})$ (same as in Definition~\ref{def:QAP}).


\item $\SpecialG.\Reprove: (\crspk, X, \pi, b, \relRQ) \mapsto (X', \pi', b')$  such that
\begin{align*}
&b ', r_1, r_2  \xleftarrow{\$} \F_p, X' = X + (b'- b) \Kgamma, \pi' = (U', V', W'), \\
&U' = \frac{1}{r_1} U, V' = r_1 V + r_1r_2[\delta]_2, W' = W + r_2U  - (b' - b) \Kdelta \mathperiod
\end{align*}
\noindent where $\pi = (U, V, W)$.
 
\item $\SpecialG.\VerifyCom: (\pp, X, \barx, b) \mapsto 0/1$ where the output is 1 iff the following holds
$$X = \sum_{i=l+1}^{n} x_i\left[ \frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma} \right]_1  + b \Kgamma,$$
where $\barx = (x_{l+1}, \ldots, x_n)$, $ 0 \leq l \leq n-1$. 
\item $\ZKCont.\Verify: (\crsvk, \bar{y}, X', \pi', \relRQ) \mapsto 0/1$ where the output is 1 iff the following holds 
$$e(U',V') = e([\alpha]_1, [\beta]_2) \cdot e(X' + Y, [\gamma]_2) \cdot e(W', [\delta]_2),$$
where $\pi' = (U', V', W')$, $Y = \sum_{i=1}^{l} x_i\left[ \frac{\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau)}{\gamma} \right]_1$ 
and $\bary = (x_1, \ldots, x_l)$.

\item $\SpecialG.\Sim: (\tw, \bary, \relRQ) \mapsto (\pi', X')$ where $u, A', B' \xleftarrow {\$} \F_p$ and let \\
$\pi' = ([A']_1, [B']_2, [C']_1)$ where $C' = \frac{A'B' - \alpha \beta - \sum_{i=1}^{l} x_i (\beta a_i(\tau)+ \alpha b_i(\tau)+ c_i(\tau))- u}{\delta}  $ and, 
by definition $\bary = (x_1, \ldots, x_l)$. Note that $\pi$ is a simulated proof for transparent input $\bary$ and commitment $X' = [u]_1$.
\end{itemize} 
\end{definition}

\noindent \paragraph{Notes:} First, the trusted setup required by \SpecialG is 
an extension of that required by original Groth16~\cite{Groth16} by two additional 
group elements $\Kgamma = [\frac{\eta}{\gamma}]_1$ and $\Kdelta = [\frac{\eta}{\delta}]_1$. 
An identical trusted setup to that used by \SpecialG was used in LegoSNARK~\cite[Fig.~22]{LegoSNARK} which defines 
a commit-carrying SNARK based on Groth16. Second, our $\SpecialG.\Reprove$ algorithm uses a Groth16 re-randomisation 
technique for the proof (see~\cite[Fig.~1]{RandomizationGroth16} or LegoSNARK~\cite[Fig.~22]{LegoSNARK}), 
but, in addition, $\SpecialG.\Reprove$ also re-randomises $X$ which is a commitment to a slice of the public input; moreover 
we appropriately define the zero-knowledge property for zk continuations such that even after iteratively applying 
$\SpecialG.\Reprove$ zero-knowledge property is preserved for both the witness as well as the public input committed to in $X$.  \\

%{\color{red}Note that, if a trusted setup is used (for example the one described in~\cite{subversion_zk}) such that there 
%exist a public and efficient procedure for verifying it, then, by extending it with $\Kgamma$ and $\Kdelta$ (which is our 
%extension of the standard Groth16 trusted setup), the resulting setup remains publicly verifiable (i.e., by using the additional 
%verification equation $e(\Kgamma, [\gamma]_2) = e(\Kdelta, [\delta]_2)$), and, hence, according to~\cite{subversion_zk}, 
%subversion zero-knowledge. }
%From page 3 of ~\cite{subversion_zk}"We change Groth?s zk-SNARK by adding extra elements to the CRS so that the CRS will become 
%publicly verifiable; this minimal step (clearly, some public verifiability of the CRS is needed in the case the CRS generator 
%cannot be trusted) will be sufficient to obtain Sub-ZK. However, choosing which elements to add to the CRS is not straightforward 
%since the zk-SNARK must remain knowledge-sound even given enlarged CRS; adding too many (or just ?wrong?) elements to the 
%CRS can break the knowledge-soundness."

\noindent Finally, we are ready to prove the following result:

\begin{theorem}
\label{sec_specialg}
Let $\relRQ$ be such that $\{a_k(X)\}_{k=0}^n$ are linearly independent polynomials. Then, in the 
AGM~\cite{Fuchs_AGM}, $\SpecialG$ is a zero-knowledge continuation as per definition~\ref{def:zk_cont}. 
\end{theorem}
\begin{proof} It is straightforward to prove that $\SpecialG$ has completeness for $\Preprove$ and for $\Reprove$. \\

\noindent In order to prove knowledge-soundness an in Definition~\ref{def:zk_cont}, first we argue that $\SpecialG$ is a 
commit-carrying SNARK with double binding as per Definition 3.4~\cite{LegoSNARK}. We use the fact that $\ccgroth$ as 
defined by the NILP detailed in Fig.22, Appendix H.5~\cite{LegoSNARK} satisfies that latter definition. Moreover, 
$\SpecialG$'s $\Setup$ together with $\Gen$ and $\ccgroth$'s $\mathit{KeyGen}$ are the same procedure. Also $\SpecialG$ 
and $\ccgroth$ share the same verification algorithm. Hence, translating the notation appropriately, $\SpecialG$ also satisfies 
the knowledge soundness properties for a cc-SNARK with double binding. \\


% we first argue that We prove knowledge-soundness by reducing it to the knowledge-soundness property of the Groth16 
%commit-carrying with double binding scheme (for short $\ccgroth$). This knowledge-soundness property has been formalised in 
%Definition 3.4~\cite{LegoSNARK} and the NILP corresponding to $\ccgroth$ has been detailed in Fig.22, Appendix H.5~\cite{LegoSNARK}. 
%Indeed, $\SpecialG$'s $\Setup$ together with $\Gen$ and $\ccgroth$'s $\mathit{KeyGen}$ are the same procedure. Moreover $\SpecialG$ 
%and $\ccgroth$ share the same verification algorithm. Since $\ccgroth$ satisfies the definition of a cc-SNARK with double binding, translating 
%the notation appropriately, $\SpecialG$ also satisfies the knowledge soundness properties for a cc-SNARK with double binding. 


\noindent Let now $A_{\SpecialG}$ be some adversary for the knowledge-soundness property as in Definition~\ref{def:zk_cont} then, we define a 
$A_{\ccgroth}$ adversary for the knowledge-soundness property as in Definition 3.4~\cite{LegoSNARK} as follows:
\begin{align*}
& \mathit{If} \ (\bary, \barx, X, \pi, b) \leftarrow A_{\SpecialG} (\crs, \pp, z, \relRQ)\  \mathit{then}  \\
& (\bary, X, \pi) \leftarrow A_{\ccgroth} (\relRQ, \crs, z)
\end{align*}

\noindent Given an extractor $E_{\ccgroth}$ for $A_{\ccgroth}$ such that it verifies Definition 3.4~\cite{LegoSNARK}, 
we construct an extractor $E_{\ccgroth}$ for $A_{\ccgroth}$ such that 
\begin{align*}
& \mathit{If} \ (\barx^*, b^*, \baromega^*) \leftarrow E_{\ccgroth} (\relRQ, \crs, z)\  \mathit{then}  \\
& \baromega^* \leftarrow E_{\SpecialG} (\relRQ, \crs, z)
\end{align*}
and we show by contradiction that $E_{\SpecialG}$ verifies Definition~\ref{def:zk_cont} for $A_{\SpecialG}$. \\

\noindent Finally, regarding zero-knowledge, it is clear that if $\pi' = (U', V', W')$ is part of the output of $\SpecialG.\Reprove$, 
then $U'$ and $V'$ are uniformly distributed as group elements in their respective groups. This holds, as long as the 
input to $\SpecialG.\Reprove$ is a verifying proof, even when the proof was maliciously generated. Hence, it is easy to check  
that the output $\pi'$ of $\SpecialG.\Sim$ is identically distributed to a proof $\pi'$ output by $\SpecialG.\Reprove$ so the perfect 
zero-knowledge property holds for $\SpecialG$. 
\end{proof}

\begin{comment}
Zero-knowledge invariably comes from random blinding factors.
Zero-knowledge continuations need rerandomizable zkSNARKs,
meaning Groth16 \cite{Groth16}, but beyond rerandomization their
unlinkability demands hiding public inputs.
In our case, we ``specialize'' Groth16 to permit alteration of \openpk
in the $\PedVRF.\OpenKey$ invocation without reproving our heavy
$\rVRF.\OpenRing$ invocation.

In Groth16 \cite{Groth16}, we have an SRS $S$ consisting of curve
points in $\grE_1$ and $\grE_2$ that encode the circuit being proven.
We follow \cite{Groth16} in discussing the SRS $S$ in terms of
its ``toxic waste''
 $(\alpha,\beta,\delta,\gamma,\tau^1,\tau^2,\ldots) \in \F_p^*$.
In other words, we could write say $[ f(\tau)/\delta ]_1$ or $[\delta]_2$
to denote an element of our SRS $S$ in $\grE_1$ or $\grE_2$ respectively,
computed by scalar multiplication of the Groth16 generators from
the toxic waste $\tau$ and $\delta$,
 but for which nobody knows the underlying $\tau$ or $\delta$ anymore.

In the SRS $S$, we distinguish the verifiers' string/key of elements
 $\chi_1,\ldots,\chi_k, \Upsilon_1,\ldots,\Upsilon_l, [\alpha]_1 \in \grE_1$ and
 $[\beta]_2, [\gamma]_2, [\delta]_2 \in \grE_2$.
% as separate from the provers' much longer string of elements in $\grE_1$ and $\grE_2$.
A Groth16 \cite{Groth16} proof takes the form 
 $\pi = (A,B,C) \in \grE_1 \times \grE_2 \times \grE_1$.
A verifier then produces a $X+Y = \sum_i^k x_i \chi_i + \sum_i^k y_i \chi_i \in \grE_1$
 from the instance's public inputs $x_i,y_i \in \F_p$ and then checks 
$$ e(A,B) = e([\alpha]_1, [\beta]_2) \cdot
 e(X+Y, [\gamma]_2) \cdot e(C, [\delta]_2) \mathperiod $$

We need the rerandomization algorithm from \cite[Fig.~1]{RandomizationGroth16}:
% to build a zero-knowledge continuation:
% https://eprint.iacr.org/2020/811
% https://github.com/arkworks-rs/groth16/pull/16/files
% \algo{rerandomize}
An existing SNARK $(A,B,C)$ is transformed into a fresh
SNARK $(A',B',C')$ by sampling random $r_1,r_2 \in \F_p$ and computing
% $$
% A' = {1 \over r_1} A, \qquad
% B' = r_1 B + r_1 r_2 [\delta]_2, \qquad
% C' = C + r_2 A \mathperiod
% $$
$$ \begin{aligned}
A' &= {1 \over r_1} A \\
B' &= r_1 B + r_1 r_2 [\delta]_2 \\
C' &= C + r_2 A \mathperiod \\
\end{aligned} $$
At this point, our $x_i$ remain identical after rerandomization,
so $X$ links $(A,B,C)$ to $(A',B',C')$.
Alone rerandomization cannot alter public inputs $x_i$, so
we instead need an opaque public input point $X$, which then becomes
part of our proof and incurs its own separate proof of correctness.

We build {\em special Groth16} aka \SpecialG by adding one fresh
basepoint $\genB_\gamma$ independent from all others,
 including the $H_{\grE}(\msg)$ in \PedVRF.%
\footnote{Apply the underlying $H_\grE$ to an input outside the \msg domain for example.}
In the trusted setup, we build one additional prover SRS element
$$ \genB_\delta := {\gamma\over\delta} \genB_\gamma \mathperiod $$
% Although $\genB_\gamma$ is independent,  we create $\genB_\delta$ during the trusted setup,  so the toxic waste $\gamma$ and $\delta$ remain secret.
After $\genB_\delta$ is created, our toxic waste $\gamma$ and $\delta$
disappear and subversion resistance could be checked
 like in \cite{cryptoeprint:2019/1162} plus also checking
$$ e(\genB_\gamma, [\gamma]_2) = e(\genB_\delta, [\delta]_2) \mathperiod $$

We now have a zero-knowledge continuation $\pi = (X,A,B,C)$ from which
our algorithm $\SpecialG.\Reprove : (X,A,B,C) \mapsto ((X',A',B',C'); b)$ produces an
unlinkable instance $\pi' = (X',A',B',C')$ by
 first sampling random $b,r_1,r_2 \in \F_p$ and then computing
$$ \begin{aligned}
X' &= X + b \genB_\gamma \\
A' &= {1 \over r_1} A \\
B' &= r_1 B + r_1 r_2 [\delta]_2 \\
C' &= C + r_2 A + b \genB_\delta \mathperiod \\
\end{aligned} $$
As our two $b$ terms cancel in the pairings, our special Groth16
rerandomization reduces to the standard Groth16 rerandomization
construction above,
 except with $X$ now an opaque Pedersen commitment.

% TODO:  Should we be saying opaque less and Pedersen more below?

Along side opaque inputs in $X = \sum_i^k x_i \chi_i$,
our verifier should typically enforce specific values by assembling
a few {\em transparent} inputs $Y = \sum_i^l y_i \Upsilon_i$ themselves.
In particular, our ring VRF verifiers should enforce the commitment
\comring for $\ring$, even if they outsource computing \comring.
We thus write $\SpecialG.\Preprove : (\bar{y}, \bar{x}; \bar{\omega}) \mapsto (X,A,B,C)$
where $(A,B,C) \leftarrow \primalgo{Groth16}.\Prove(\bar{y}, \bar{x}; \bar{\omega})$,
so a full \Prove algorithm works by composing \Preprove and \Reprove.

At this point $\SpecialG.\Verify(\bar{y}; (X',A',B',C') )$
 computes $X' + Y = X' + \sum_i^l y_i \Upsilon_i$ and checks
 the tuple $(X' + Y,A',B',C')$ like Groth16 does,
$$ e(A',B') = e([\alpha]_1, [\beta]_2) \cdot
 e(X' + Y, [\gamma]_2) \cdot e(C', [\delta]_2) \mathperiod $$
As our verifier does not build $X'$ themselves, we prove nothing
with this pairing equation unless the verifier separately checks
 a proof-of-knowledge that $X' = b \genB_\gamma + \sum_i^k x_i \chi_i$
 for some unknown $b,\bar{x}$.

\begin{lemma}\label{lem:unlinkable}
Our rerandomization procedure % $(X,A,B,C) \mapsto (X',A',B',C')$
transforms honestly generated \SpecialG zero-knowledge continuation $(X,A,B,C)$
into identically distributed \SpecialG proof $(X',A',B',C')$,
with identical opaque inputs $x_1,\ldots,x_k$ and
 identical transparent inputs $y_1,\ldots,y_l$.
\end{lemma}

\begin{proof}[Proof idea.]
Adapt the proof of Theorem 3 in \cite[Appendix C, pp. 31]{RandomizationGroth16}.
\end{proof}

% \begin{corollary}\label{cor:unlinkable}
%	If $\sigma'$ and $\sigma''$ are \PedVRF{}s then ???
% \end{corollary}

All told, our opaque rerandomization trick converts any conventional
Groth16 zkSNARK $\pi$ for $\Lring^\inner$ into a zkSNARK $\pi'$ for $\Lring$
with inputs split into a transparent part $\bar{y}$ vs opaque unlinkable part $X$.
% We explore two concrete $\pi$ proposals below.

Importantly, rerandomization requires only
 four scalar multiplications on $\ecE_1$ and
 two scalar multiplications on $\ecE_2$,
which  BLS12 curves make roughly equivalent to
 eight scalar multiplications on $\ecE_1$.

\begin{lemma}\label{lem:knowledge_soundness}
Assuming AGM plus the $(2n-1,n-1)$-DLOG assumption, and
 circuit size less than $n$,
then our zero-knowledge continuation \SpecialG plus a proof-of-knowledge for $X$ satisfies knowledge soundness.
\end{lemma}

\begin{proof}[Proof idea.]
As our \Prove is composed from \Preprove and \Reprove, our challenger
learns the actual public input wire values and blinding factors.
Adapt the proof of Theorem 2 in \cite[\S3, pp. 9]{RandomizationGroth16},
observing that $K_\gamma$ and $K_\delta$ never interact with other elements. 
TODO: Use PoK of $X$.
%TODO: Alistair or Oana, Do we even need the first sentense here?  nything more to say about the second?
\end{proof}

In fact, one could prove zero-knowledge continuations satisfy
weak white-box simulation extractability,  % under similar restrictions,
much like Theorem 1 in \cite[\S3, pp. 8 \& 11]{RandomizationGroth16}.
%TODO:  Alistair or Oana, what the hell did I mean by this?  -Jeff
We depend upon the specific simulator though, which itself increases
our dependence upon the usage of the zero knowledge continuation.
\end{comment}

\input{r1_r2.tex}