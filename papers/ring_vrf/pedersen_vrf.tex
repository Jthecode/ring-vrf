\section{Ring VRF construction}% {Ring VRFs from the Pedersen VRF}
\label{sec:pederson_vrf}

In the following we instantiate our ring VRF construction with an efficient evaluation proof, which
we call the Pedersen VRF and denote \PedVRF.
\PedVRF instantiates the NIZK for the relation $\Reval$ introduced in a general form 
in \S\ref{sec:overview}. In this section we focus upon Pedersen VRF and the relations 
describing a SNARK for ring membership; we discuss the zero-knowledge continuation
that makes the overall ring VRF efficient in the next section.

Our ring VRF construction works with public parameters $ \pprvrf = (\crsrvrf, p,\grE, \genG,\genB, \setsym{S}_{eval}  = \F_p)$ generated by $ \rVRF.\Setup(1^\secparam) $. Here, $ p $ is a prime number and the order of the group $ \grE $ which has generators $ \genG,\genB $.  $ \crsrvrf $ is a common reference string generated by $ \NIZK_{\Rring}.\Setup(1^\secparam) $. Our ring VRF construction deploys random oracles $H_p,H: \{0,1\}^* \to \F_p$, $H_{\grE}: \{0,1\}^* \to \grE$ and $ H_{\ring} $ for constructing a Merkle tree.

%We refer readers to \S\ref{sec:ec_background} for notation,
% like our curves and hash functions.
%In particular miss-use resistance dictates \PedVRF be instantiated with
%two elliptic curves: $\ecE$ (or $\ecE_1$) handles key commitments
% build with two independent base points $\genG$ and $\genB$,
%We hash-to a ``sister'' Edwards curve $\ecEsis$ with a subgroup $\grEsis$
% of the same order $p$ as $\grE$.
%In practice $\grEsis$ has cofactor $\hsis$ divisible by 4, while
% $\grE$ might have effective cofactor 1 if deserialization enforces subgroup checks.
%Any readers only interested in theoretical security arguments
%should assume $\ecEsis = \ecE$ and $\hsis = 1 = h$,
% while implementers should read more carefully.
We first describe Pedersen VRF before giving our ring VRF construction.
\paragraph{Pedersen VRF:} 
We construct \PedVRF similarly to 
\cite{nsec5,VXEd25519,draft-irtf-cfrg-vrf-10},
except we replace the public key by a Pedersen commitment
$\sk \, \genG + \openpk \, \genB$ to the secret key \sk.
We do not expose a public key from \KeyGen, nor inject the public key in \Eval.

\begin{itemize}
	\item $\PedVRF.\KeyGen: \pprvrf \mapsto \sk$  where $\sk \leftsample \F_p$. % and $\pk = \sk \, \genG$.
	\item $\PedVRF.\Eval : (\sk,\msg) \mapsto H(\msg, \PreOut)$ where $\PreOut = \sk \, H_{\grE}(\msg)$.
\end{itemize}
\noindent We add an algorithm to obtain a Pedersen commitment to the secret key \sk.
\begin{itemize}
	\item $\PedVRF.\CommitKey: \sk \mapsto (b, \compk)$ \,
	where  $\openpk \leftsample \F_p$ is a blinding factor
	and $\compk = \sk \, \genG + \openpk \, \genB$ is a Pedersen commitment.
	% \item $\PedVRF.\OpenKey(\compk,\openpk)$ \,
	% returns $\pk = \compk - \openpk \, \genB$.
	% \item $\PedVRF.\OpenKey(\sk,\openpk)$ \,
	% returns $\compk = \sk \, \genG + \openpk \, \genB$.
\end{itemize}
%We do not expose an opening algorithm here because opening occurs inside
%our zero knowledge continuation,
%as described in $\Rring$ and \S\ref{sec:rvrf_cont} blow.

Our \Sign and \Verify algorithms of \PedVRF correspond to
the \Prove algorithm and verification procedure of a Chaum-Pedersen DLEQ proof
for relation $\mathcal{R}_{eval}$ (see below),
instantiated by a Fiat-Shamir transform of a sigma protocol.

$$ \mathcal{R}_{eval} = \Setst{
	\begin{aligned}
		& (\compk,\PreOut,\In) ; \\ 
		& \,\, (\sk, \openpk) 
	\end{aligned}
}{
	\begin{aligned}
		& \compk = \sk\,\genG + \openpk\,\genB, \\
		& \,\, \PreOut = \sk \, H_{\grE}(\msg) 
	\end{aligned}
}  \mathperiod \label{rel:commit} 
$$




\begin{itemize}
	\item $\PedVRF.\Sign : (\sk,\openpk,\msg,\aux) \mapsto \sigma$ \,.
	% takes a secret key \sk and blinding factor \openpk, an input $\msg$, and associated data \aux, and then performs
	% $ \NIZK_{\mathcal{R}_{eval}}.\Prove(((\genG, \genB,\grE,\compk,\PreOut,\In); (\sk, \openpk))) $
	% $ \sigma = (\PreOut,\compk,\pi_{eval}) $
	Compute $\PreOut := \sk \, H_{\grE}(\msg)$ and $ \compk = \sk \genG + \openpk\genB $. Then, run $\NIZK_{\rel_{eval}}.\Prove(\compk, \PreOut, \msg;\sk,\openpk,\msg)  $ which generates a Chaum-Pedersen DLEQ proof
	for relation $\mathcal{R}_{eval}$ i.e.,
	let $r_1,r_2 \leftsample \F_p$
	and compute $R = r_1 \genG + r_2 \genB, R_m = r_1 H_{\grE}(\msg) $ and $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$, finally compute $s_1 = r_1 + c \, \sk$ and $s_2 = r_2 + c \, \openpk$ and let $ \pi = (R,R_m,s_1,s_2) $.
	Return the signature $\sigma = (\PreOut,\pi) $.
	% and return the signature $\sigma = (\PreOut,c,s_1,s_2)$.
	
	\item $\PedVRF.\Verify : (\compk,\msg,\aux,\sigma) \mapsto {\color{red}\Out \,\, \lor \perp}$ \,.
	% $ \NIZK_{\mathcal{R}_{eval}}.\Verify(\genG, \genB,\grE,\compk,\PreOut,\In, \pi_{eval} ) $
	Parse $\sigma = (\PreOut, R,R_m,s_1,s_2) $ and compute 
	$c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$.
	If $ R = s_1 \genG + s_2 \genB - c \, \compk$ and
	and $ R_m = s_1 H_{\grE}(\msg) - c \, \PreOut$,
	% First parse $\sigma = (\PreOut, \pi_{eval} =(c,s_1,s_2))$,
	% recompute $\In := H_{\grEsis}(\msg)$, 
	% $R = s_1 \genG + s_2 \genB - c \, \compk$, and
	% $R_m = s_1 \In - c \, \PreOut$.
	% Finally if $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$ holds,
	then return $H(\msg,\PreOut)$, which equals $\PedVRF.\Eval(\sk,\msg)$,
	or return failure $\perp$ otherwise.
\end{itemize}




% DESCRIPTION WITH COFACTOR
%\begin{itemize}
%    \item $\PedVRF.\KeyGen$ \, returns $\sk \leftsample \F_p$. % and $\pk = \sk \, \genG$.
%    \item $\PedVRF.\Eval : (\sk,\msg) \mapsto H'(\msg, \hsis\,\PreOut)$ where $\PreOut = \sk \, H_{\grEsis}(\msg)$.
%\end{itemize}
%\noindent We instead add an algorithm to obtain a Pedersen commitment to the secret key \sk.
%\begin{itemize}
%    \item $\PedVRF.\CommitKey(\sk)$ \,
%    returns a blinding factor $\openpk \leftsample \F_p$
%    and a commitment $\compk = \sk \, \genG + \openpk \, \genB$.
%    % \item $\PedVRF.\OpenKey(\compk,\openpk)$ \,
%    % returns $\pk = \compk - \openpk \, \genB$.
%    % \item $\PedVRF.\OpenKey(\sk,\openpk)$ \,
%    % returns $\compk = \sk \, \genG + \openpk \, \genB$.
%\end{itemize}
%We do not expose an opening algorithm here because opening occurs inside
%our zero knowledge continuation,
% as described in $\Rring$ and \S\ref{sec:rvrf_cont} below.
%
%Our \Sign and \Verify algorithms of \PedVRF correspond to
%the \Prove and \Verify algorithms of a Chaum-Pedersen DLEQ proof
% for relation $\mathcal{R}_{eval}$,
%instantiated by a Fiat-Shamir transform of a sigma protocol.
%$$ \mathcal{R}_{eval} = \Setst{
	%  \begin{aligned}
		%    & (\compk,\PreOut,\In) ; \\ 
		%    & \,\, (\sk, \openpk) 
		%  \end{aligned}
	%}{
	%  \begin{aligned}
		%    & \compk = \sk\,\genG + \openpk\,\genB, \\
		%    & \,\, \PreOut = \sk\,\In 
		%  \end{aligned}
	%}  \mathperiod \label{rel:commit} 
%$$
%%
%\begin{itemize}
%	\item $\PedVRF.\Sign : (\sk,\openpk,\msg,\aux) \mapsto \sigma$ \,
%	% takes a secret key \sk and blinding factor \openpk, an input $\msg$, and associated data \aux, and then performs
%    % $ \NIZK_{\mathcal{R}_{eval}}.\Prove(((\genG, \genB,\grE,\compk,\PreOut,\In); (\sk, \openpk))) $
%    % $ \sigma = (\PreOut,\compk,\pi_{eval}) $
%	First compute $\In := H_{\grEsis}(\msg)$ and $\PreOut := \sk \, \In$ and \compk.
%	Next sample random $r_1,r_2 \leftsample \F_p$
%	to compute $R = r_1 \genG + r_2 \genB$ and $R_m = r_1 \In$.
%	Compute the challenge $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$.
%	Finally compute $s_1 = r_1 + c \, \sk$ and $s_2 = r_2 + c \, \openpk$.
%	and return the signature $\sigma = (\PreOut,R,R_m,s_1,s_2)$.
%	% and return the signature $\sigma = (\PreOut,c,s_1,s_2)$.
%
%	\item $\PedVRF.\Verify : (\compk,\msg,\aux,\sigma) \mapsto \Out \,\, \lor \perp$ \,
%	% $ \NIZK_{\mathcal{R}_{eval}}.\Verify(\genG, \genB,\grE,\compk,\PreOut,\In, \pi_{eval} ) $
%	First parse $\sigma = (\PreOut, \pi_{eval} = (R,R_m,s_1,s_2))$,
%	recomputes $\In := H_{\grEsis}(\msg)$ and 
%	$c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$.
%    Finally if $h \, R = h \, (s_1 \genG + s_2 \genB - c \, \compk)$ and
%    and $h \, R_m = h \, (s_1 \In - c \, \PreOut)$ both hold,
%	% First parse $\sigma = (\PreOut, \pi_{eval} =(c,s_1,s_2))$,
%	% recompute $\In := H_{\grEsis}(\msg)$, 
%    % $R = s_1 \genG + s_2 \genB - c \, \compk$, and
%    % $R_m = s_1 \In - c \, \PreOut$.
%    % Finally if $c = H_p(\aux,\msg,\compk,\PreOut,R,R_m)$ holds,
%    then return $H(\msg, \hsis\,\PreOut)$, which equals $\PedVRF.\Eval(\sk,\msg)$,
%    or return failure $\perp$ otherwise.
%\end{itemize}



%\noindent We described the deterministically batchable flavor analogous
%to \cite{HdVBatchEd25519} because $s_2$ makes our signature large enough
%that half-aggregation makes sense, unlike EC VRF. %NOT CLEAR SENTENCE
We remark that \PedVRF becomes almost EC VRF if
we demand $\openpk = r_2 = 0$ in \Sign.
%but our public key handling in \PedVRF breaks VRF definitions somewhat. %NOT CLEAR SENTENCE

\paragraph{The Ring VRF Construction:} We now describe how our ring VRF construction works as a combination of $ \PedVRF $, $ \NIZK_{\Rring} $ (for a relation 
$\Rring$ instantiated below) and a commitment scheme $ \mathsf{Com} $.

\begin{itemize}
	\item $\rVRF.\KeyGen$ \, returns as secret key $\sk,r \leftsample \F_p$ and $ \pk $ as public key where $ \pk = \mathsf{Com}.\mathsf{Commit}(\sk,r)  $. We note that $ \pk  $ can be alternatively defined as $ \pk = \sk \genG $ according to the SNARK used for $ \Rring $. In this case, we would not have $ r $ as a part of the secret key.  We provide one optimal public key design in \S\ref{subsec:rvrf_faster} for our SNARK used for $ \Rring $. 
	
	\item $\rVRF.\Eval((\sk,r), \msg) $ runs $\PedVRF.\Eval(\sk,\msg)$. We remark that the evaluation value is generated with \emph{only} the first part of the secret key which is $ \sk $.
	
	\item $ \rVRF.\CommitRing: (\ring,\pk) \mapsto (\comring,\openring)$ compute a Merkle tree root $\comring  $ using random oracle $ H_\ring $ considering the elements of $ \ring $ as leaves and generating a  Merkle tree path $ \openring $ that verifies $ \pk \in \ring $.
	
	\item $ \rVRF.\OpenRing: (\comring, \openring) \mapsto \pk $ verify that the root computed via Merkle tree path $ \openring $ is  $ \comring $. If it is the case, output $ \pk \in \openring $. Otherwise, output $ \perp $. 
	
	We choose the ring commitment scheme so the $\rVRF.\OpenRing$ invocation
	is relatively SNARK friendly in our ring membership relation $ \Rring $. We note that an alternative ring commitment scheme may be used 
	where $ \comring = \ring $ and $ \openring = \pk $, however as we will see below, it incurs a high cost of $O(|\ring|)$ for the ring VRF verifier. 
		
\end{itemize}

\noindent The \Sign and \Verify for  our \rVRF are a combination of \Sign and \Verify from \PedVRF and
\Prove and \Verify from $\NIZK_{\Rring}$, as follows:
\def\tmpaux{\aux \doubleplus \piring \doubleplus \comring}
\def\tmpeprintaux{\eprint{\aux'}{\tmpaux}}
\def\tmpindent{\hspace*{5pt}}
\begin{itemize}
	
	\item $\rVRF.\rSign : ((\sk,r),\comring, \openring,\msg,\aux) \mapsto \rho$
	returns a ring VRF signature $\rho = (\compk,\piring,\sigma, \comring)$
	if \openring is a correct opening of \comring.  In this, $(\openpk,\compk) \leftarrow \PedVRF.\CommitKey(\sk)$,  $\piring \leftarrow \NIZK_{\Rring}.\Prove((\compk,\comring); \openpk,\openring, \pk,\sk,r)$ where  $\aux' \leftarrow \tmpaux$,  $\sigma \leftarrow \PedVRF.\Sign(\sk,\openpk,\msg, \aux')$.  We instantiate  $ \Rring 
	$\footnote{We note that if $ \pk = \sk\genG $ then $ \Rring $ does not need $ \sk,r $ as a part of the witness. In this case we need to replace the last two conditions by $ \compk = \pk + \openpk \genB $.} with

	
	$$ \Rring = \Setst{ (\compk,\comring ;\openpk,\openring,\sk,r) }{
		\begin{aligned}
			&	\pk = \OpenRing(\comring,\openring), \\
			& 	\sk = \mathsf{Com}.\mathsf{Open}(\pk,r), \\
			& 	\compk = \sk \genG + \openpk \genB
		\end{aligned}	
	}$$
	\item $\rVRF.\rVerify : (\comring,\msg,\aux,\rho) \mapsto {\color{red} \Out \,\, \lor \perp}$ \, 
	parses $\rho$ as $(\compk,\piring,\sigma)$,  sets $\aux' \leftarrow \tmpaux$ and runs $\NIZK_{\Rring}.\Verify((\compk,\comring); \piring)$.
	If it fails, returns $ (0,\perp) $. Otherwise, returns $\PedVRF.\Verify(\compk,\msg, \aux', \sigma)$.
\end{itemize}


% BEGIN TODO: Oana

% % Although \PedVRF itself exhibits surprising properties, our gestalt 
% \rVRF satisfies sensible security definitions:
% Pseudo-randomness holds by reduction to singleton rings.
% Ring uniqueness, ring unforgeability, and ring anonymity resemble security
% arguments for other ring signatures built from SNARKs.

% \begin{proposition}\label{prop:rvrf_games}
	% $\rVRF$ satisfies ring uniqueness, ring unforgeability, and ring anonymity.
	% \end{proposition}

% END TODO: Oana

Appendix \ref{ap:ucproof} proves our ring VRF construction realizes $ \fgvrf $ in Figure \ref{f:gvrf}. Intuitively, the randomness and the determinism of $ \rVRF.\Eval $ come from the random oracles $ H' $ and $ H_{\grE'} $.  The anonymity of our ring VRF signature comes from the perfect hiding property of Pedersen commitment, the zero-knowledge property of $ \NIZK_{\mathcal{R}_{ring}} $ (Lemma \ref{lem:anonymity}) and the difficulty of DDH in  $ \grE $ (Lemma \ref{lem:honestoutput}) so that $ \PreOut $ is indistinguishable from a random element in $ \grE $. The unforgeability and uniqueness come from the fact that CDH is hard in $ \grE $ (Lemma \ref{lem:simulation-ind}), i.e., for unforgeability,  one cannot commit an honest party's secret key without breaking the CDH problem and for the uniqueness,  if one can obtain $ \PedVRF $ signatures such that $ \sigma_1 = (\PreOut_1, \pi_{\PedVRF}) $ and $ \sigma_2 = (\PreOut_2, \pi'_{\PedVRF}) $ where  $ \PreOut_1 \neq \PreOut_2 $  and verified by \compk for the message \msg, then we break a CDH problem in $ \grE $.

\begin{theorem}\label{thm:rvrfmain}
	$ \rVRF $  over the group structure $ (\grE,p,\genG,\genB) $ realizes $ \fgvrf $ in Figure \ref{f:gvrf} in the random oracle model assuming that $ \NIZK_{\mathcal{R}_{eval}} $ and $ \NIZK_{\mathcal{R}_{ring}}$ are zero-knowledge and knowledge sound, the decisional Diffie-Hellman (DDH) problem are hard in $ \grE  $ and the commitment scheme $ \mathsf{Com} $ is binding and perfectly hiding. 
\end{theorem}
%TODO: Proof Sketch
% NOTE:  Is this redundant after the above paragraph?
% The security proof of Theorem \ref{thm:rvrfmain} is in Appendix \ref{ap:ucproof}.



\endinput
