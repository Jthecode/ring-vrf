\section{Ring updates}
\label{sec:ring_updates}

We discuss \pifast representing public keys in $\grE$ in $\grJ$ already,
% along with circuit implementation details of $\PedVRF.\{ \CommitKey, \OpenKey \}$,
but otherwise mostly treated the ring commitment scheme
$\rVRF.\{ \CommitRing, \CommitKey, \OpenKey \}$ like a black box.

Although our $\rVRF.\rSign$ run fast, all users must update their
stored SNARK \pifast every time the ring $\ctx$ changes.
Almost any circuit works for \pifast though,
 which permits diverse optimizations depending upon usecase.


\subsection{Merkle trees} % {Poseidon}

In either \pifast and \pisafe configurations, 
our $\rVRF.\{ \CommitRing, \CommitKey, \OpenKey \}$ could implement a
Merkle tree using SNARK friendly hash functions like Poseidon \cite{poseidon}.
%
All users need $O(\log |\ctx|)$ data with every update, which sounds
reasonable but not free.  There is a fast moving literature on securing
and optimizing SNARK friendly hash functions, with different techniques
being better suited to different SNARKs or even curves.

TODO: Arity 9 for 300 constraints?   % \cite{groth16} vs plookup \cite{plookup}.

We leave deeper discussion of SNARK friendly Merkle to the literature.
Instead we spend this section focusing upon the diversity of circuit
designs that fit our \pifast and \pisafe framework.


\subsection{Vector commitments}

Instead of Merkle trees, our SNARk $\pi$ could use polynomial based
vector commitments \cite{KZG} or so called ``Verkle trees'' \cite{??Verkle??} too.
%
Aggregatable subvector commitments \cite{aSVC} permit one server to
compute a KZG commitment \comring together with every users' ring opening
\openring,  and then send each user their \openring encrypted.
Instead of Groth16 \cite{groth16}, our \pisafe then consists
of additively blinding this KZG commitment and then open it in zero-knowledge.

TODO: Explain zero-knowledge KZG opening positions?!?

We cannot replace \pifast with a KZG commitment directly like this,
but could split \pifast into two parts similar to \pisafe and $\psisafe'$.

replace $\pisafe'$ with a zero-knowledge continuation
that swaps the KZG blinding for the secret key blinding used by \pifast.

We represent public keys in $\grE_1$ over $\ecJ$ like \pifast does,
so $J = \sk_0\, \genJ_0 + \sk_1\, \genJ_1 + b' \genJ_2$.
After placing these into a KZG commitment over $\ecE$, a transperent
openning yields $J.x Y_2 + J.y Y_3$, so our blinded opening could
then yield $J.x Y_2 + J.y Y_3 + b \genB_\gamma$.
At this point, we need a SNARK to translate $J$ into $\sk$, so
$$ \pifast' = \rrSNARK \Setst{ \sk_0 + \sk_1 2^128, \pk }{ 
 \exists b' \textrm{\ s.t.\ }
 % 0 < \sk_0,\sk_1 < 2^128 \textrm{\ and\ } 
 \pk = \sk_0 \genJ_0 + \sk_1 \genJ_1 + b' \genJ_2
} \mathperiod $$
We compute $\pifast'$ only once ever, unlike $\pisafe'$.

We must reblind the KZG commitment with each VRF signature, and
tweak $\PedVRF$ to prove knowledge for $Y_2$ and $Y_3$, so 
our marginal prover time remains higher than naieve \pifast here.
We impose additional pairings upon verifiers too, likely suboptimal.


\subsection{Certificates} % \& revokation}

If an authority grants ring membership, then ring membership proofs
could simply verify some certificate by the authority, likely using
a signature on JubJub.

In this, we prefer a SNARK friendly random oracle,
because conventional random oracles cost like 30k constraints.
We also need a variable base scalar multiplication, which costs like
4k constraints, as well as a couple fixed base scalar multiplication.
A priori, these fixed base scalar multiplications cost roughly 700
constraints each, but ocasionally they cost only half this.   

We conjecture one fixed based scalar multiplication could be replaced
by adapting implicit certificate scheme technqiues,
 instead of simply a signature on a user provided key.

We typically need expiration dates in certificates, likely demanding
a range proof and maybe requiring that \pifast be recomputed more often.

% \subsection{Revokation}

A priori, we cannot revoke ring membership when using certificates,
but revokation of ring membership winds up rare in practice, especially
since ring membership cannot be traced across site so easily.

We could therefore employ a seperate revokation list and inside \pifast
do a non-membership proof like \cite{???}.
In this way, we update \pifast only when the revokation list updates,
far less often than the full ring \ctx itself updates, and likely
corresponding with expiration checks.

We already trust an authority with issuing certificates here, so
we shall trust them with managing therevokation list too.  As such,
our revokation list non-membership proofs requires proving adjacency
of the revoked public keys lexicographically before and after our own
public key.  If the revokation list requires secrecy, then VRFs could
hide its ordering, similarly to NSEC5 \cite{nsec5}.


\subsection{Append only logs}

If an append only log grants ring membership, then a recursive SNARK
could validate ring membership with each recursive addition being
relatively inexpensive.

In this, we need a $\pifast_0$ similar to \pifast as well as a
$\pifast_n$ that proves some $\comring_{n-1}$ to be the ancestor of
its own $\comring_n$ and recursively proves some $\pifast_{n-1}$ with
its own $\comring_{n-1}$ and the same $\sk$.
We expect half pairing cycles fit this usage nicely, although they complicate provers.

Append only logs still depand \piast or \pisafe be reproven whenever
\ctx updates however, so they benefit less than certificates from revokation lists.

A priori, we expect prover complexity plus update fequency makes
append only logs suboptimal, but
 they remain an interesting corner of the design space.

