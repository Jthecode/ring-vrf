\newcommand{\name}{rVRF}

\label{ap:ucproof}
\label{sec:ringvrfconstrnoPK}
\newcommand{\GG}{\grE}
\newcommand{\FF}{\F}
\newcommand{\hash}{H}
\newcommand{\hashG}{\hash_\grE}
\newcommand{\gen}{\mathsf{Gen}}
\newcommand{\hkeys}{\mathtt{honest\_keys}}
\newcommand{\malkeys}{\mathtt{malicious\_keys}}
\newcommand{\rcom}{\mathcal{R}_{eval}}
\newcommand{\rsnark}{\Rring}
\newcommand{\counter}{\mathsf{counter}}
\newcommand{\bdv}{\mathcal{B}}
\newcommand{\abort}{\textsc{Abort}}
\newcommand{\pkeys}{\arraysym{public\_keys}}
\newcommand{\skeys}{\arraysym{secret\_keys}}
\newcommand{\keytransform}{T_{\mathsf{key}}}
%Before giving the security proof of our protocol, we give the protocol in Section \ref{sec:pederson_vrf} without the abstraction from $ \PedVRF $ for the sake of  clarity of the security proof.
%
%We instantiate parameter generation by constructing a group $\GG$ of order $ p $ and two generators $ \genG, \genB \in  \GG$.  We consider three hash functions: $ \hash, \hash_p: \{0,1\}^* \rightarrow \FF_p $ and a hash-to-group function $\hashG : \{0,1\}^* \rightarrow \GG$ and . \name \ works as follows:
%
%\begin{itemize}
%	\item $ \rVRF.\KeyGen(1^\kappa):  $ It selects randomly a secret key $ x \in \FF_p$ and computes the public key $ X = xG $. In the end, it outputs $ \sk = x $ and $ \pk = X $.
%	
%	%It also generates  PoK for the discrete logarithm of $ X $ for the relation $ \R_{dl} $, $ \NIZK.\Prove(\rdl, (x, (X, G, \GG))) \rightarrow \pi_{dl} $.
%	
%	%\begin{equation}
%	%	\rdl = \{(x,(X,G,\GG)): X,G \in \GG, x \in \FF_p, x = xG\}
%	%\end{equation}
%	
%	%For this, it does the following: $ a \leftsample \FF_p $, $ c = \hash_p(a\genG, X) $, $ s = a + cx $. 
%	
%	%	\item $ \rVRF.\eval(\sk, \ring, m) $: It lets $ P = \hashG(m, \ring) $ and computes $ W = xP  $. Then, it outputs $ y = \hash(m, \ring, W) $. So, the deterministic function $ F $ in our rVRF protocol is $ F(\sk, \ring, m) = H(m, \ring, x\hashG(m,\ring)) $.
%	%	
%	\item $ \rVRF.\Sign(\sk, \ring, m):$ It lets $ \In = \hashG(m) $ and computes the pre-output $ \PreOut= x\In$. The signing algorithm works as follows: 
%
%	\begin{itemize}
	%		
	%		\item It first commits to its secret key $
	%		x$ i.e., $ \compk = X + \openpk \, \genB $ where $ \openpk \leftsample \FF_p $.
	%		\item It generates a Chaum-Pedersen DLEQ proof $ \pi_{eval} $ showing the following relation by running the algorithm $ \NIZK_{\rcom}.\Prove(((\genG, \genB,\GG,\compk,\PreOut,\In); (x, \openpk))) $ which outputs $ \rightarrow \pi_{eval}$
	%		\eprint{\begin{align}
			%				\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): 
			%				\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} 
			%		\end{align}}{
		%		\begin{align}
			%			\rcom= \{((x, \openpk), (\genG, \genB,\GG,\compk,\PreOut,\In)): \\
			%			\compk = x\genG + \openpk\, \genB, \PreOut = x \,\In \} \label{rel:commit} \nonumber
			%		\end{align}}
	%		Here $ \Prove $ algorithm runs a non-interactive Chaum-Pedersen DLEQ proof with the Fiat-Shamir transform:  Sample random $r_1, r_2 \leftarrow \F_p$.
	%		Let $R = r_1 \genG + r_2 K$, $R_m = r_1 \In$, and
	%		$c = \hash_p(\ring, m, \PreOut,\compk,R,R_m)$.
	%		Set $\pi_{eval} = (c,s_1,s_2)$ where $s_1 = r_1 + c x$ and $s_2= r_2 + c \, \openpk$.
	%		\item %It obtains $ crs $ from $ \gcrs $ for the second proof by sending the message $ (\oramsg{learncrs}, \sid) $ to $ \gcrs $. Then,
	%		%It constructs a Merkle tree $ \mathsf{MT} $ with the nodes $ X_i $ where  $ X_i \in \pk_i $ and $ \pk_i \in  \ring $. We denote its  root by $ \mathsf{root} $. In the end, 
	%		It generates the second proof $ \pi_{ring} $ for the following relation with  the witness $ (\ring, x, \openpk) $. 		
	%		
	%		\eprint{\begin{equation}
			%				%\rsnark = \{((\mathsf{copath}, X, \openpk),(G,\genB\GG,\mathsf{root}, \compk)): C-\openpk K = X, \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) \rightarrow 1\} \label{rel:snark}
			%				\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \compk-\openpk \, \genB = X \in \ring\} \label{rel:snark}
			%			\end{equation}
		%		}{\begin{align}
			%			\rsnark = \{(X, \openpk),(\genG,\genB,\GG,\ring, \compk)): \\\compk-\openpk \, \genB = X \in \ring\} \label{rel:snark} \nonumber
			%		\end{align}
		%	}
	%		
	%		%Here, $ \mathsf{copath} $ is a copath of the Merkle tree $ \mathsf{MT} $. $ \mathsf{MT}.\Verify(\mathsf{copath}, X, \mathsf{root} ) $ is a verification algorithm of the Merkle tree which verifies whether $ X $ is the one of the leaves of $ \mathsf{MT} $ i.e., compute a root $ \mathsf{root}' $ with $ X $ and $ \mathsf{copath} $ and output 1 if $ \mathsf{root} = \mathsf{root}' $.
	%		
	%		The second proof $ \pi_{ring} $ is generated by running 
	%		$ \NIZK_{\rsnark}.\Prove(((\genG,\genB,\GG,\ring, \compk); (X, \openpk))) $ 
	%	\end{itemize}
%	In the end, $ \rVRF.\Sign $ outputs $\sigma = (\pi_{eval}, \pi_{ring}, \compk, \PreOut) $.
%	
%	\item $ \rVRF.\Verify(\ring,\PreOut, m, \sigma) $: Given $  \sigma = (\pi_{eval}, \pi_{ring},\compk)  $ and $ \ring, \PreOut $,
%	% it first runs $ \NIZK.\Verify(\rdl,(X_i,\genG,\GG), \pi_{dl_i}) $ for each $ \pk_i= (X_i, \pi_{dl_i})  \in \ring $. If each of key in $ \ring $ verifies,
%	it runs $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ where $ P = \hashG(m) $. $ \NIZK_{\rcom}.\Verify $ works as follows: $ \pi_{eval} = (c,s_1, s_2) $, it lets $R' = s_1 \genG + s_2 \, \genB - c \,\compk$ and $R'_m = s_1 \hashG(m) - c \, \PreOut$. It
%	returns true if $c = \hash_p(\ring,m,\PreOut,\compk,R',R'_m)$. If  $ \NIZK_{\rcom}.\Verify((\genG, \genB,\GG,\compk,\PreOut,\In), \pi_{eval} ) $ outputs 1, it runs $ \NIZK_{\rsnark}.\Verify((\genG,\genB,\GG,\ring, \compk), \pi_{ring}) $. 
%	If all verification algorithms verify, it outputs $ 1 $ and the evaluation value $ y =  \hash(m,\PreOut)  $. Otherwise, it outputs $( 0, \perp) $.
%	
%\end{itemize}
%
%\subsection{Security Analysis}

\subsection{Security Analysis of Our First Protocol}

We should first define $ \gen_{sign} $  for $ \fgvrf $ and show that  $ \gen_{sign} $ satisfies the anonymity defined in Definition \ref{def:anonymity} so that $ \fgvrf $ gives anonymity. 



%\begin{algorithm}
%	\caption{$\gen_{W}(\ring,\pk,m)$}
%	\label{alg:genW}	 	
%	\begin{algorithmic}[1]
	%		\State$ W \leftsample\GG $
	%		%		\State \textbf{get} $ X \in \pk $
	%		%		\If{$\mathtt{DB}[m, \ring] = \perp  $}		
	%		%		\State{$ a \leftsample \FF_p $}		
	%		%		\State{$\mathtt{DB}[m, \ring] := a$}
	%		%		\EndIf
	%		%		\State$ a \leftarrow \mathtt{DB}[m, \ring] $
	%		%		
	%		%		\State \textbf{return} $ aX $
	%		\State \textbf{return} $ W $
	%	\end{algorithmic}
%	
%\end{algorithm}

%\begin{algorithm}
%	
%	\caption{$\gen_{sign}(\ring,W,x,\pk,\aux,\msg)$}
%	\label{alg:gensign}	 	
%	\begin{algorithmic}[1]
	%		\State $ c,s_1, s_2 \leftsample \FF_p $
	%		\State $ \pi_{eval}  \leftarrow (c,s_1, s_2)$
	%		\State $ \openpk \leftsample \FF_p $
	%		\State $ \compk =  x \genG + \openpk \, K$
	%		%\State $ \pi_{eval} \leftarrow \NIZK.\mathsf{Simulate}(\rcom, (G, \genB,\GG,\compk,W,\In)) $
	%		%\State \textbf{send} $(\oramsg{learn\_\tau},\sid)  $ to $ \gcrs $
	%		%\State \textbf{receive} $(\oramsg{trapdoor},\sid, \tau,crs)  $ from $ \gcrs $
	%		\State $ \comring, \openring \leftarrow \rVRF.\CommitRing(\ring, \pk) $
	%		\State $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\Prove(\comring, \compk\; \openpk, \openring, x) $ 
	%		\State\Return$ \sigma = (\pi_{eval},\pi_{ring},\compk,\comring,W) $
	%	\end{algorithmic}
%	
%\end{algorithm}


\begin{lemma} \label{lem:anonymity} $ \Gen_{sign}$ in Algorithm \ref{alg:gensign} satisfies anonymity defined in Definition \ref{def:anonymity} assuming  $ \NIZK_{\rsnark} $ is ZK and Pedersen commitment is perfectly hiding.
\end{lemma}

\begin{proof} Assume that $ \mathcal{D} $ wins the anonymity game for $ \Gen_{sign} $ with an advantage $ \epsilon $.
We reduce the anonymity game to a game where we remove the line \ref{rel:commit} and change the line \ref{line:piring} of Algorithm \ref{alg:gensign} with $ \pi_{ring} \leftarrow \NIZK_{\rsnark}.\mathsf{Simulate}(\tw_{\Rring}, \pp_{\Rring},\comring, \compk) $ where $ \comring $ is the Merkle root of $ \ring $ obtained via $ \hash_\ring $.  Our new game is indistinguishable since $ \NIZK_{\rsnark} $.  Since in the new game, proofs are generated without the keys and $ \compk $ is perfectly hiding,   $ \mathcal{D} $ wins the new game with probability $ \frac{1}{2} $. Thus, $ \epsilon $ is negligible.		
\end{proof}

%We next show that our first protocol  realizes $ \fgvrf $  in the random oracle model under the assumption of the hardness of the decisional Diffie Hellman (DDH).

%The GDH problem is solving the computational DH problem by accessing the Diffie-Hellman oracle ($ \mathsf{DH}(.,.,.) $) which tells that given triple $ X,Y,Z $ is a DH-triple i.e., $ Z = xyG $ where $ X = xG $ and $ Y = yG $.

%\begin{definition}[$ n $-One-More Gap Diffie-Hellman (OM-GDH) problem]
%	Given   $ p $-order group $ \GG $ generated by $ G $, the challenges $ G, X = xG, P_1, P_2, \ldots, P_{n+1} $ and access to the DH oracle $ \mathsf{DH}(.,.,.) $ and the oracle $ \mathcal{O}_x(.) $ which returns $ x\In$ given input $ \In$, if a PPT adversary $ \mathcal{A} $ outputs $ xP_1, xP_2, \ldots, xP_{n+1} $ with the access of at most $ n $-times to the oracle $ \mathcal{O}_x $, then $ \mathcal{A}  $ solves the $ n $-OM-GDH problem. We say that $ n $-OM-GDH problem is hard in $ \GG $, if for all PPT adversaries, the probability of solving the $ n $-OM-GDH problem is negligible in terms of the security parameter.
%\end{definition}
Below, we give the security statement for our first construction when $ \pk $ is defined as $ \mathsf{Com}.\mathsf{Commit}(\sk,r) $ where $ (\sk, r) $ is the secret key (Case 1) and  when $ \pk $ is defined as $ \pk = \sk\genG $ where $ \sk $ is the secret key (Case 1).
\begin{theorem}\label{thm:firstprotocol}
	Our first protocol over  $ pp_{rvrf} $ realizes \cite{canetti1,canetti2}  $ \fgvrf $ running $ \Gen_{sign} $ in Algorithm \ref{alg:gensign} in the random oracle model assuming that $ \NIZK_{\mathcal{R}_{eval}} $ and $ \NIZK_{\mathcal{R}_{ring}}$ are zero-knowledge and knowledge sound, the decisional Diffie-Hellman (DDH) problem are hard in $ \grE  $ \eprint{(so the CDH problem is hard as well)}{and the commitment scheme $ \mathsf{Com} $ is computationally binding and perfectly hiding for Case 1}. 
\end{theorem}

\begin{proof}
	We construct a simulator $ \simulator $ that simulates the honest parties in the execution of our protocol and simulates the adversary in $ \fgvrf $. 
	\begin{itemize}
		%\item \textbf{[Simulation of $ \gcrs $:] }When simulating $ \gcrs $, it runs $ \mathsf{SNARK}.\mathsf{SetUp}(\rsnark) $ which outputs a trapdoor $ \tau $ and $ crs $ instead of picking $ crs $ randomly from the distribution $ \distribution $. Whenever a party comes to learn the $ crs $, $ \simulator $ gives $ crs $ as  $ \gcrs $.
		
		\item \textbf{[Simulation of $ \oramsg{keygen} $:]} Upon receiving $(\oramsg{keygen}, \sid, \user_i)$ from $\fgvrf$, $ \simulator $ generates  a secret and public key pair $ x = (\sk,r)$ and $\pk $ by running $ \rVRF.\KeyGen $. It adds $ \pk $ to a list $ \hkeys $  as a key of $ \user_i $.
		In the end, $ \simulator $ returns $(\oramsg{verificationkey}, \sid, x,\pk)$ to $\fgvrf$. 
		$ \simulator $ sets $ \pkeys[X] = \pk$ and $ \skeys[X] =(\sk,r) $ where $ X = \sk \genG $.
		During the simulation, $ \simulator $ populates $ \pkeys $ with hypothetical public keys which are never revealed during the simulation or by $ \fgvrf $. However, it does not populate $ \skeys $ except this part of the simulation. So, if  $ \pkeys[X'] $ is not empty for a value $ X' $ but $ \skeys[X'] $ is empty, it means that $ \simulator $ generated the entry $ \pkeys[X'] $ just for the sake of the simulation with a key which is not  functional as a real public key.
		%Whenever the honest party $ \user $ is corrupted by $ \env, $ $ \simulator $ moves the key of $ \user $ to $ \malkeys $ from $ \hkeys $.
		
		\item \textbf{[Simulation of corruption:]} Upon receiving a message $ (\oramsg{corrupted}, \sid, \user_i) $ from $ \fgvrf $, $ \simulator $ removes the public key $ \pk $ from $ \hkeys $ which is stored as a key of $ \user_i $ and adds $ \pk $ to $ \malkeys $.
		
		\item\textbf{[Simulation of the random oracles:]} We  describe how $ \simulator $ simulates the random oracles $ \hashG, \hash, \hash_p $ against the real world adversaries. 	
		
		$ \simulator $ simulates the random oracle $ \hashG $ as described in Figure \ref{oracle:HgnoPK}. It selects a random element  $ h $ from $ \FF_p $ for each new input and outputs $ hG $ as an output of the random oracle $ \hashG $. Thus, $ \simulator $ knows \emph{the discrete logarithm of each random oracle output of $\hashG  $}. 
		
		
		The simulation of the random oracle $ \hash $ is less straightforward (See Figure \ref{oracle:HnoPK}).
		The value $ W $ can be a $ \PreOut $ of an input generated by a malicious party or can be an anonymous key of  $ \msg $ generated by $ \fgvrf $ for an honest party. $ \simulator $ does not need to know about this but $ \hash $ should output $ \evaluationslist[\msg,W] $ in both cases to be consistent with $ \fgvrf $.	 
		%If $ W $ is a pre-output, $ \simulator $ needs to find corresponding malicious public key in the real world. If it is the case, $ W $ should be equal to $ x\hashG(m, \ring)= xhG $  where $ xG $ is a public key. 
		$ \simulator $ treats $ W $ as if it is $ \PreOut $ generated as in the protocol. So, $ \simulator $ first obtains the discrete logarithm $ h $ of $ \hashG(\msg) $ from the $ \hashG $'s database and obtains $ X^* = h^{-1}W $.    
		%If $ X^* $ has not been registered as a malicious key, it registers it to $ \fgvrf $. Thus, $ \simulator $ has a right to ask the output of the message $ m, \ring $ to $ \fgvrf $. 
		$ \simulator $ checks if $ \pkeys[X^*] $ exists If it does not exist, $ \simulator $ samples randomly a key $ \pk^* $ which is not stored in $ \pkeys $ and stores $ \pkeys[X^*] = \pk^* $ just to use while sending $ \oramsg{eval} $ to $ \fgvrf $. Then, it sends  $ (\oramsg{eval}, \sid,\pk^*,W,\msg) $ to $ \fgvrf $ and receives back $ \evaluationslist[\msg,W] $.
		Remark that if $ W $ is a pre-output generated by $ \adv $, then $ \fgvrf $ matches it with the evaluation value given by $ \fgvrf $. If $ W $ is an anonymous key of an honest party in the ideal world, $ \fgvrf $ still returns an honest evaluation value $ \evaluationslist[\msg,W] $ even if $ \simulator $ cannot know whether $ W $ is an anonymous key of an honest party in the ideal world. 
		% Remember that $ \fgvrf $ only replies to the evaluation message of $ \simulator $ if $ W $ is not mapped to another message, ring and public key $ (m', \ring', X')   $. $ W $ cannot be map to $ (m', \ring', X')   \neq  (m, \ring, X*)   $ because it would be aborted during the simulation $ \hashG $ if they were mapped to $ W $.
		During the simulation of $ \hash $, if $ \fgvrf $ aborts, then there exists $ W' \neq W $ such that $ \anonymouskeymap[\msg,W'] = \pk^* $. Remark that it is not possible because if it happens it means that $ hX^* = W' \neq W  $ where $ \pkeys[X^*] = \pk^* $, but also $ W = hX^* $. 
		Therefore, \abort-1 never occurs.
		
%		We note that the anonymous keys for honest parties generated by $ \fgvrf $ are independent from their keys. Therefore, if $ \skeys[h^{-1}W] $ is defined, $ \simulator $ returns a random value because  $ \evaluationslist[\msg,W] $ is not defined or will not be defined in $ \fgvrf $ in this case except with a negligible probability. If it is ever defined, i If it ever happens it means that $ \fgvrf $ selects randomly $ W  $ randomly which actually equals to $ hX^*$. If such things happen in $ \fgvrf $, $ \env $ distinguishes the simulation via honest signature verification in the real world. So, this case is covered in our simulation in Figure \ref{oracle:Hout}.
		

		\begin{figure}
			\begin{minipage}{.4\textwidth}

				\centering
				\noindent\fbox{%
					\parbox{2cm}{%
						\scriptsize
						\underline{\textbf{Oracle $ \hashG $}} \\
						\textbf{Input:} $ \msg $ \\
					
						\textbf{if} $\mathtt{\hashG}[\msg] = \perp  $
						
						\tab{$ h \leftsample \FF_p $}
						
						%					\tab{\textbf{for all} $ X \in \ring $}
						%					
						%					\tab{$ W =  hX $}
						%					
						%					\tabdbl{\textbf{if} $ W \in \anonymouskeylist $: \textsc{Abort}}
						%					
						%					\tabdbl{\textbf{else:} \textbf{add} $ W $ \textbf{to} $ \anonymouskeylist $}
						
						\tab{\textbf{return} $ h\genG $} 
						
						\tab{$\mathtt{\hashG}[\msg] := h$}
						
						\textbf{else}:
						
						\tab{$ h \leftarrow \mathtt{\hashG}[\msg] $}
						
						\tab{\textbf{return} $  h\genG$}
						
						
				}}	
				\caption{The random oracle $ \hashG $}
				\label{oracle:HgnoPK}

			\end{minipage}%
			\begin{minipage}{0.6\textwidth}
				\centering
				\scriptsize
				\noindent\fbox{%
					\parbox{6cm}{%
						\underline{\textbf{Oracle $ \hash$}} \\
						\textbf{Input:} $ \msg,W $ 
						
						\textbf{if} $\mathtt{\hash}[\msg, W] \neq \perp $
						
						\tab{\textbf{return $ \mathtt{\hash}[\msg,  W] $}}
						
						%					\textbf{send} $ (\oramsg{request}, \sid, \emptyset,W, m) $ \textbf{to} $ \fgvrf $
						%					
						%					\textbf{receive} $ (\oramsg{requests}, \sid, \emptyset, W, m, \setsym{L}_\sigma, y) $ \textbf{from} $ \fgvrf $
						
						%					\textbf{if} $ y = \perp $
						
						{$ P \leftarrow \hashG(\msg) $}
						
						{$ h \leftarrow \mathtt{\hashG}[\msg] $}
						
						{$ X^* := h^{-1}W $ // candidate commitment key} 
						
%						{{\textbf{if} $\skeys[X^*] = \perp$ }} 
						
						{\textbf{if} $ \pkeys[X^*]  = \perp$}
						
						\tabdbl{$ \pk^* \leftsample \grE $} %TODO put the space of pk's
						
						\tabdbl{$ \pkeys[X^*] := \pk^* $}
						
						{\textbf{send} $ (\oramsg{eval}, \sid, W, \pkeys[X^*] , \msg) $ \textbf{to} $ \fgvrf $}
						
						{\textbf{if} $ \fgvrf $ ignores: \abort-1}
						
						{\textbf{receive} $ (\oramsg{evaluated}, \sid, W, \msg, y) $ \textbf{from} $ \fgvrf $}
						
						{$ \mathtt{\hash}[\msg, W]:=y $}
						
%						{\textbf{else:} }
%						
%						\tab{$ y \leftsample \FF_p $}
%						
%						\tab{$ \mathtt{\hash}[m,  W]:=y $}
						%					{\textbf{else:} $\mathtt{\hash}[m, \ring, W]  = \perp$}
						%					
						%					%\tab{\textbf{return} \textsc{Abort}}
						%					\tab{$ y \leftsample \bin^\lambda $}
						%					
						%					\tab{$\mathtt{hash}[m, \ring, W] := y $}
						
						%	\textbf{else:} $ \mathtt{\hash}[m,  W]:=y $
						
						\textbf{return $ \mathtt{\hash}[\msg,  W] $}
						
				}}	
				\caption{The random oracle $ \hash $}
				\label{oracle:HnoPK}
			\end{minipage}
		\end{figure}
		


		The simulation of the random oracle $ \hash_p $ (See Figure \ref{oracle:Hout} for details) given the query  query $ (\aux', \msg,\compk,W,R,R_m)  $ makes sure that the verified signature $ \sigma = (\pieval, \piring, \compk, \comring) $ of honest parties verifies $ \pieval = (c, s_1,s_2) $ via $ H_p $ as in the protocol. For this, it first parses $ \aux' $ as $\tmpaux $. If $ \piring $ is verified via $ \NIZK_{\mathcal{R}_{ring}} $, then oracle $ H_p $ deduces that the reply to this oracle query might obtained from $ \fgvrf $ in case $ \compk,\piring,\comring $ are  a part of a valid honest signature.
		 If the oracle $ H_p $ obtains such verified signature $ \sigma $ from $ \fgvrf $, it returns $ c $ if $ R = s_1 \genG + s_2 \genB - c \compk $ and $ R_m = s_1 \hashG(\msg) - cW $. We remark that if $ R $ and $ R_m $ satisfy these equalities, it means that they correspond to $ R $ and $ R_m $ generated during $ \rVRF.\Verify $ which is supposed to output 1  for the part of $ \pieval $.
		 
		
%		We remind that if an anonymous key $ W $   for an input  $ \msg$  equals to a pre-output generated by $ \rVRF.\Sign $  for an honest party's key and the the input $ \msg $, then $ \env $ can distinguish the ideal and real world outputs. The reason of this is that the evaluation value in the ideal world and real world for $ \msg,W $ will be different because of the simulation of the random oracle $ \hash $ i.e., $\mathtt{\hash}[\msg,W] \neq \evaluationslist[\msg,W] $.  Therefore, $ \simulator $ aborts if it is ever happen.
		
		\begin{figure}
			\centering
			\scriptsize
			\noindent\fbox{%
				\parbox{\textwidth}{%
					\underline{\textbf{Oracle $ \hash_p $}} \\
					\textbf{Input:} $ (\aux', \msg,\compk,W,R,R_m) $ \\					
					
					\textbf{parse} $ \aux' $ as $\tmpaux $
%					
%					{$ h := \mathtt{\hashG}[m,W] $ }
%						
%					{\textbf{if} $ \skeys[h^{-1}W] \neq \perp $: \abort-2}
					
					\textbf{if} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m] \neq \perp $: \textbf{return} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m] $
					
					
					\textbf{else if} \textbf{ $ \NIZK_{\Rring}.\Verify((\compk,\comring);\piring) \rightarrow 1 $}
					
					\tab{\textbf{send} $ (\oramsg{request\_signatures},\sid, \aux, W,\msg) $}
					
					\tab{\textbf{receive} $ (\oramsg{signatures},\sid,\msg, \setsym{L}_\sigma) $}
					
					\tab{\textbf{if} $ \exists \sigma', \sigma \in \setsym{L}_\sigma $ such that $\sigma = (., \piring, \compk, \comring)  $ \textbf{and} $  \sigma' = (., \piring, \compk, \comring) $: \abort-2}
					
					\tab{\textbf{else if} $\exists \sigma \in \setsym{L}_\sigma $ such that $\sigma = (\pieval, \piring, \compk, \comring)  $ for some $ \pieval $}
					
					\tabdbl{\textbf{get} $ \pieval = (c,s_1, s_2) $} 
					
					\tabdbl{\textbf{if} $ R = s_1\genG + s_2 \genB -c\compk, R_m = s_1 \hashG(\msg) - c W $}  
					
				
					
					
				
					
				%	\tabdbldbl{\textbf{if} $( \mathtt{H_p}[\aux, m,\compk,W,R,R_m] = c' \in \FF_p$ where $ c' \neq c $: \abort-4 }
					
					
					
					
%					\tabdbldbl{\textbf{else if} $ \mathtt{H_p}[\aux, m,\compk,W,R,R_m]  = \perp $}
					
					\tabdbldbl{$ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  := c$}
			
	
					\textbf{if} $ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  = \perp $
					
					\tab{$ c \leftsample \FF_p $}
					
					\tab{$ \mathtt{H_p}[\aux', \msg,\compk,W,R,R_m]  := c$}
					
					{\textbf{return} $  \mathtt{H_p}[\aux',\msg,\compk,W,R,R_m]   $}
					
 			}}
			\caption{The random oracle $ \hash_p $}
			\label{oracle:Hout}
		\end{figure}
		
		
		%		\item \textbf{[Simulation of $ \oramsg{sign} $]} 
		%		The simulator has a table  $\preoutputlist $ to keep the pre-outputs that it selects for each input and the ring of public keys. 
		%		Upon receiving $(\oramsg{sign}, \sid, \ring, m, y)$  from the functionality $\fgvrf$, $ \simulator $ generates the signature $ \sigma $ as follows:
		%		
		%		For the first proof, it samples $ c, s_1, s_2 \in \FF_p $ and $ \compk, W \in \GG$. Then, it lets the first proof be $\pi_1 =  (c, s_1, s_2) $. 
		%		In addition, it sets $ R = sG+ \delta K+ c\compk $ and $ R_m = s \hashG(m, \ring)+ cW $ and maps the input $ \ring,m, W,\compk, R, R_m$ to $ c $ in the table of the random oracle $ \hash_p $ so that $ \pi_1 $ verifies in the real-world execution.  
		%		It adds $ W $ to the list $ \preoutputlist[m, \ring] $.
		%		
		%		$ \simulator $ gets the trapdoor $ \tau $ that it generated during the simulation of $ \gcrs $ to simulate the second proof. Then, it runs $ \mathsf{SNARK}.\mathsf{Simulate}(\rsnark,\tau, crs) $ and obtains $ \pi_2 $.
		%		
		%		In the end, $ \simulator $  responds by sending the message $(\oramsg{signature}, \sid, \ring, m, \sigma = (\pi_1, \pi_2, \compk, W))$ to the $ \fgvrf $.  It also lets $\mathtt{\hash}[m, \ring, W] $ be $ y $, if it is not defined yet. If it is defined with another value $ y' \neq y $, then it aborts.
		%TODO: Talk about this abort case happens with a negl probability. 
		
		
		\item \textbf{[Simulation of $ \oramsg{verify} $]} Upon receiving  $(\oramsg{verify}, \sid, \ring,W, \aux,\msg, \sigma)$ from the functionality $\fgvrf$, $ \simulator $ runs $ \rVRF.\Verify $ algorithm of our ring VRF protocol. If  it verifies, it sets $ b_{\simulator} =1 $. Otherwise it sets $ b_{\simulator} =0  $.
		
		\begin{itemize}
			\item 		If $ b_\simulator = 1 $, it sets $ X = h^{-1} W$ where $ h = \mathtt{\hashG}[m] $. Then it obtains $ \pk  = \pkeys[X]$ if it exists. If it does not exist, it picks a $ \pk  $ which is not stored in $ \pkeys $ and sets $ \pkeys[X] = \pk $. Then it sends  $ (\oramsg{verified}, \sid, \ring, W,\aux,\msg, \sigma, b_\simulator, \pkeys[X]) $ to $ \fgvrf $ and receives back $ (\oramsg{verified}, \sid, \ring, W, \aux, \msg, \sigma, y, b) $. 
			
			 If $ b \neq b_\simulator $, it means that the signature is not a valid signature in the ideal world, while it is in the real world. So, $ \simulator $ aborts in this case (\abort-3).
				If $ \fgvrf $ does not verify a ring signature even if  it is verified in the real world, $ \fgvrf $ is in either C3-\ref{cond:uniqueness}, \ref{cond:forgery} or C3-\ref{cond:differentWforsamepk}.
				If $ \fgvrf $ is in C3-\ref{cond:uniqueness}, it means that $ \counter[\msg,\ring] > |\ring_{mal}| $. If $ \fgvrf $ is in C3-\ref{cond:forgery}, it means that $ \pk$ belongs to an honest party but this honest party never signs $ \msg $ for  $ \ring $. So, $ \sigma $ is a forgery.	 If $ \fgvrf $ is in C3- \ref{cond:differentWforsamepk}, it means that there exists $ W' \neq W $ where $ \anonymouskeymap[\msg,W'] = \pk$. If $ [\msg,W'] $ is stored before, it means that $ \simulator $ obtained $ W' = hX $ where $ h =\mathtt{\hashG}[\msg] $ but it is impossible to happen since $ W = hX $.
			
				 If $ b = b_\simulator $, it sets $\mathtt{\hash}[m,W] = y $, if it is not defined before.
				% In short, if $ \simulator $ aborts because $ b\neq b_\simulator $ it means either $ W $ of an honest party is not unique and $ \adv $ in the real world generates a forgery signature of $ (m, \ring, \sigma) $ with $ W $ or the adversary in the real world generates anonymous keys for $ (m, \ring) $ more than the number of adversarial keys in $ \ring $.
				%				 
				
				%	\item If $ b = b_\simulator $, set $\mathtt{\hash}[m, W] = y $. Here, if $ \sigma $ is a signature of an honest party, $ \simulator $ sets its output with respect to the output selected by $ \fgvrf $. 
				%    Remark that we do not need to set $ \mathtt{H_p} $ because it already verifies in the real world.

			\item If $ b_\simulator = 0 $, it sets $ \pk = \perp $ and sends  $ (\oramsg{verified}, \sid, \ring, W,\aux, m, \sigma, b_\simulator, X) $ to $ \fgvrf $. Then, $ \simulator $ receives back $ (\oramsg{verified}, \sid, \ring, W, \aux,m, \sigma, \perp, 0) $. 
			%			\begin{itemize}
				%				\item If $ b \neq b_\simulator $, it means that it was a signature of an honest party and $ \NIZK.\Verify $ for $ \rcom $ does not validate in the real world. So, $ \simulator $ sets $\mathtt{\hash}[m, \ring,W] = y $ and $ \mathtt{H_p}[\ring, m, W, \compk, R', R_m'] = c $ where $ R' = s\genG + \delta K+ c\compk  $, $ R_m = s \hashG(m,\ring) + cW$. 
				%				Now, the signature verifies in the real world as well.
				%				\item If $ b = b_\simulator $, $ \simulator $ doesn't need to do anything.
				%			\end{itemize}
			
		\end{itemize}
		
		
		
		
		
		
	\end{itemize}
	
	We remark that \abort-2 happens in the oracle $ H_p $ described in Figure \ref{oracle:Hout} in case  $ W $ is generated by $ \fgvrf $ for an honest party. The reason of this is that $ \fgvrf $ asks for $ \simulator $ to verify or not verify all signatures with  $ W $ which is not generated by $ \fgvrf $. $ \simulator $ runs $ \rVRF.\Verify $ for all such requests and replies accordingly. Therefore, the valid signatures for $ \msg, \aux' $ with malicious $ W $ (obtained via $ \oramsg{request\_signatures} $) must been already validated by $ \simulator $ before and $ \mathtt{H_p}[(\aux', \msg,\compk,W,R,R_m)] $ has been assigned with a random value. 
	
	We next show that the outputs of honest parties in the ideal world are indistinguishable from the honest parties running our second protocol. 
	
	\begin{lemma}\label{lem:honestoutput}
		Assuming that the DDH problem is hard on $ \GG $, the outputs of honest parties in the real protocol \name\ are indistinguishable from the output of the honest parties in $ \fgvrf $ running $ \Gen_{sign} $  in Algorithm \ref{alg:gensign}
	\end{lemma}

	\textit{Proof Sketch:} 	The the honest evaluation outputs generated by $ \fgvrf $ and generated by $ H $ in the real world protocol are in the identical distribution. The ring VRF signatures of honest parties in two worlds ($ (\piring, \compk, \comring, \pieval, W) $ in $ \fgvrf $ and $ (\piring, \compk, \comring, \pieval, \PreOut) $ in $ \rVRF $) are in different distributions because $ W $ and $ \PreOut $ generated differently while the rest is in identical distribution. We can show both ring VRF distributions are indistinguishable under the assumption that DDH problem is hard (See Appendix \ref{ap:ucproof}).
	
	
	Next we show that the simulation executed by $ \simulator $ against $ \adv $ is indistinguishable from the real protocol execution.
	
	\begin{lemma} \label{lem:simulation-ind}
		The view of $ \adv $ in its interaction with the simulator $ \simulator $ is indistinguishable from the view of $ \adv $ in its interaction with real honest parties assuming that CDH is hard in $ \GG $, $\hashG, \hash, \hash_p, \hash_\ring $ are random oracles, $ \NIZK_{\rcom}, \NIZK_{\rsnark} $ are knowledge sound and $ \mathsf{Com} $ is computationally binding and perfectly hiding. 
	\end{lemma}

	\textit{Proof Sketch:} The  simulation against the real world adversary $ \adv $ is identical to the real protocol except the cases where $ \simulator $ aborts. \abort-1 cannot happen as we explained during the simulation.  \abort-2 happens if $ \Gen_{sign} $ generates the same $ \compk $ for two different signatures. This happens if $ \fgvrf $  select same $ \compk $ for two different honest signature which happens with a negligible probability.
	Now, we are left with the abort case (\abort-3) during the verification.
	For this, we show that if there exists an adversary $ \adv $ which makes $ \simulator $ abort during the simulation, then we construct another adversary $ \bdv $ which breaks either the CDH problem or the binding property of $ \mathsf{Com}$  (See Appendix \ref{ap:ucproof}).
	
	
	This completes the security proof of our first  ring VRF protocol. \qed
\end{proof}

